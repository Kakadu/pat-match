open OCanren

let flip f a b = f b a

module W = Work_base_common
open W

let id x = x
let ( >>=? ) x f = match x with None -> None | Some x -> f x
let failwiths fmt = Printf.ksprintf failwith fmt

(* ************************************************************************** *)
(* Natural numbers generated by work (i.e. not from OCanren stdlib) *)
module N = struct
  type 'a gnat = 'a W.gnat = Z | S of 'a
  [@@deriving gt ~options:{ show; fmt; foldl; gmap; compare }]

  type ground = ground gnat
  [@@deriving gt ~options:{ show; fmt; foldl; gmap; compare }]

  type logic = logic gnat OCanren.logic
  [@@deriving gt ~options:{ fmt; foldl; gmap; compare }]

  type injected = (ground, logic) OCanren.injected

  let z : injected = W.z ()
  let one : injected = W.s z
  let s = W.s

  let show (n : ground) =
    let rec helper acc = function
      | Z -> string_of_int acc
      | S n -> helper (acc + 1) n
    in
    helper 0 n

  let show_logic n =
    let rec helper acc : logic -> string = function
      | Value Z -> string_of_int acc
      | Value (S n) -> helper (acc + 1) n
      | Var _ as n ->
          if acc <= 0 then GT.show OCanren.logic (show_gnat_logic 0) n
          else
            Printf.sprintf "(%d+%s)" acc
              (GT.show OCanren.logic (show_gnat_logic 0) n)
    and show_gnat_logic acc : logic gnat -> string = function
      | Z -> string_of_int acc
      | S n -> helper (acc + 1) n
    in
    helper 0 n

  let ground =
    {
      ground with
      GT.plugins =
        object
          method show = show
          method fmt = ground.GT.plugins#fmt
          method foldl = ground.GT.plugins#foldl
          method compare = ground.GT.plugins#compare
          method gmap = id
        end;
    }

  let logic =
    {
      logic with
      GT.plugins =
        object
          method show = show_logic
          method fmt = logic.GT.plugins#fmt
          method foldl = logic.GT.plugins#foldl
          method compare = logic.GT.plugins#compare
          method gmap = id
        end;
    }

  (* *********** *)

  let rec reify env x = W.For_gnat.reify reify env x
  let rec prjc onvar env xs = W.For_gnat.prjc (prjc onvar) onvar env xs

  let inject : ground -> injected =
   fun root ->
    let rec helper = function Z -> z | S p -> s @@ helper p in
    helper root

  let to_ground_exn n =
    let rec helper = function
      | Var _ -> raise Not_found
      | Value Z -> Z
      | Value (S x) -> S (helper x)
    in
    helper n

  let rec to_ground = function
    | Var (_, _) -> None
    | Value Z -> Some Z
    | Value (S x) -> to_ground x >>=? fun x -> Some (S x)

  let of_int n =
    let rec helper acc n = if n = 0 then acc else helper (S acc) (n - 1) in
    if n < 0 then assert false else helper Z n

  let to_int =
    let rec helper acc = function Z -> acc | S x -> helper (acc + 1) x in
    helper 0
end

(* ************************************************************************** *)
module Tag = struct
  type ground = GT.int [@@deriving gt ~options:{ foldl; compare }]
  type logic = GT.int OCanren.logic [@@deriving gt ~options:{ foldl; compare }]
  type injected = (ground, logic) OCanren.injected

  let all_tags =
    [
      "zero";
      "succ";
      "true";
      "false";
      "nil";
      "cons";
      "nil2";
      "pair";
      "A";
      "B";
      "C";
      "int";
      "triple";
      "D";
      "Push";
      "Search";
      "Ldi";
      "Pushenv";
      "Popenv";
      "Extend";
      "Apply";
      "Mkclos";
      "Mkclosrec";
      "IOp";
      "Test";
      "Clo";
      "Int";
      "Val";
      "Env";
      "Code";
      "42";
    ]

  let of_int x = x
  let to_int x = x

  let string_of_tag_exn tag =
    let n = to_int tag in
    match List.nth all_tags n with
    | s -> s
    | exception Not_found ->
        failwith (Printf.sprintf "Bad argument %d in tag_of_string_exn" n)

  let inttag_of_string_exn s =
    match Base.List.findi all_tags ~f:(fun _ -> String.equal s) with
    | Some (n, _) -> n
    | None -> failwith (Printf.sprintf "Bad argument %S in tag_of_string_exn" s)

  let tag_of_string_exn s : ground = of_int (inttag_of_string_exn s)
  let of_string_exn = tag_of_string_exn

  exception HasFreeVars

  (*
  let show_logic l =
    let rec helper acc = function
      | Value Z -> acc
      | Value (S next) -> helper (1+acc) next
      | Var _ -> raise HasFreeVars
    in
    try string_of_tag_exn (N.of_int (helper 0 l))
    with HasFreeVars -> GT.show N.logic l
  *)

  let rec is_coercible_to_ground tag =
    match tag with
    | Value Z -> true
    | Var _ -> false
    | Value (S p) -> is_coercible_to_ground p

  let show_logic = GT.show OCanren.logic @@ string_of_tag_exn

  let ground =
    {
      ground with
      GT.plugins =
        object
          method show = string_of_tag_exn
          method fmt f x = Format.fprintf f "@[%s@]" (string_of_tag_exn x)
          method gmap x = x
          method foldl = ground.GT.plugins#foldl
          method compare = ground.GT.plugins#compare
        end;
    }

  let logic =
    {
      logic with
      GT.plugins =
        object
          method show = show_logic
          method fmt f l = Format.fprintf f "@[%s@]" (show_logic l)
          method gmap x = x
          method foldl = logic.GT.plugins#foldl
          method compare = logic.GT.plugins#compare
        end;
    }

  let reify = N.reify
  let inject = N.inject
  let prjc = N.prjc
  let to_ground = N.to_ground
  let to_ground_exn = function Value x -> x | Var _ -> failwith "bad argument"
  let reify = OCanren.reify
  let inject = ( !! )
  let prjc = OCanren.prjc
  let to_ground = function Var _ -> None | Value x -> x
end

(* TODO: put this to stdlib *)
let rec inject_ground_list (xs : ('a, 'b) OCanren.injected Std.List.ground) :
    ('a, 'b) Std.List.groundi =
  (* TODO: tail recursion *)
  let rec helper = function
    | Std.List.Nil -> Std.List.nil ()
    | Std.List.Cons (x, xs) -> Std.List.cons x (helper xs)
  in
  helper xs

let ground_list_length xs = GT.foldl Std.List.ground (fun acc _ -> acc + 1) 0 xs

let ground_list_iteri f xs =
  GT.foldl Std.List.ground
    (fun acc x ->
      f acc x;
      acc + 1)
    0 xs
  |> ignore

let ground_list_foldi f init xs =
  GT.foldl Std.List.ground
    (fun (i, acc) x ->
      let ans = f acc i x in
      (i + 1, ans))
    (0, init) xs
  |> snd

let ground_list_fold2i_exn f init xs ys =
  let open Std.List in
  let rec helper acc n = function
    | Nil, Nil -> acc
    | Cons (x, xs), Cons (y, ys) -> helper (f acc n x y) (n + 1) (xs, ys)
    | _ -> failwith "bad length"
  in
  helper init 0 (xs, ys)

let logic_list_len_lo =
  let rec helper acc = function
    | Var (_, _) -> acc
    | Value (Std.List.Cons (_, tl)) -> helper (acc + 1) tl
    | Value Std.List.Nil -> acc
  in
  helper 0

module MatchableKind = struct
  type injected =
    (gmatchable_kind, gmatchable_kind OCanren.logic) OCanren.injected

  let pp_logic ppf x =
    GT.fmt logic
      (fun ppf -> function
        | GoodSubTree -> Format.fprintf ppf "good"
        | MissExample -> Format.fprintf ppf "miss"
        | MissTotally -> assert false)
      ppf x

  let good : injected = goodSubTree ()
  let miss_example : injected = missExample ()
  let miss_totally : injected = missTotally ()
  let reify = OCanren.reify
end

module Pattern = struct
  type ('a, 'b) t = ('a, 'b) W.gpattern = WildCard | PConstr of 'a * 'b
  [@@deriving gt ~options:{ fmt; gmap; foldl }]

  type ground = (Tag.ground, ground Std.List.ground) t
  [@@deriving gt ~options:{ fmt; gmap; foldl }]

  type logic = (Tag.logic, logic Std.List.logic) t OCanren.logic
  type injected = (ground, logic) OCanren.injected

  let constr = W.pConstr
  let wc = W.wildCard

  let rec height = function
    | WildCard -> 0
    | PConstr (_, ps) ->
        GT.foldl Std.List.ground (fun acc x -> max acc (height x)) 0 ps + 1

  let parented flg pp fmt x =
    if flg then Format.fprintf fmt "(%a)" pp x else pp fmt x

  let show : ground -> string =
    let pp ppf =
      GT.transform ground
        (fun fself ->
          object
            method c_WildCard ppf _ = Format.fprintf ppf "_"

            method c_PConstr ppf _ name ps =
              match ps with
              | Std.List.Nil -> Format.fprintf ppf "%a" (GT.fmt Tag.ground) name
              | ps ->
                  Format.fprintf ppf "%a (" (GT.fmt Tag.ground) name;
                  ground_list_iteri
                    (fun n x ->
                      if n > 0 then Format.fprintf ppf ", ";
                      fself ppf x)
                    ps;
                  Format.fprintf ppf ")"
          end)
        ppf
    in
    Format.asprintf "%a" pp

  (*
    let rec helper ~par ppf = function
    | WildCard -> Format.fprintf ppf "_"
    | PConstr (t, Std.List.Nil) ->
        Format.fprintf ppf "%a" (parented par (GT.fmt Tag.ground)) t
    | PConstr (s, ps) ->
        (* TODO: write decent code here  *)
        Format.fprintf ppf "(%s "
(*          (if par then "(" else "")*)
          (GT.show Tag.ground s);
        let (_:int) = GT.foldl Std.List.ground (fun n x ->
            Format.fprintf ppf "%s, %a"
              (if n=0 then "" else ",")
              (helper ~par:false) x;
            (1+n)
          ) 0 ps
        in
        (*Format.fprintf ppf "%a"
          (GT.fmt Std.List.ground (helper ~par:true)) ps;*)
        Format.fprintf ppf ")"
(*          (if par then ")" else "")*)
    in
    Format.asprintf "%a" (helper ~par:false)
*)
  let show_logic : logic -> string =
    let rec helper : (Tag.logic, logic Std.List.logic) t -> string = function
      | WildCard -> "_"
      | PConstr (s, OCanren.Value Std.List.Nil) ->
          let (_ : Tag.logic) = s in
          GT.show Tag.logic s
      | PConstr (s, ps) ->
          Printf.sprintf "(%s %s)" (GT.show Tag.logic s)
            (GT.show Std.List.logic (GT.show OCanren.logic helper) ps)
    in
    GT.show OCanren.logic helper

  let count_constructors : ground -> int =
    GT.transform ground
      (fun fself ->
        object
          method c_PConstr acc _ _ args =
            GT.foldl OCanren.Std.List.ground fself (1 + acc) args

          method c_WildCard acc _ = acc
        end)
      0

  let count_wildcards : ground -> int =
    GT.transform ground
      (fun fself ->
        object
          method c_PConstr acc _ _ args =
            GT.foldl OCanren.Std.List.ground fself acc args

          method c_WildCard acc _ = acc + 1
        end)
      0
end

(* ************************************************************************** *)
module Expr = struct
  type ('a1, 'a0) t = ('a1, 'a0) W.gexpr = EConstr of 'a1 * 'a0
  [@@deriving gt ~options:{ compare }]

  type ground = (Tag.ground, ground Std.List.ground) t
  [@@deriving gt ~options:{ compare }]

  type logic = (Tag.logic, logic Std.List.logic) gexpr OCanren.logic
  type injected = (ground, logic) OCanren.injected

  let rec prjc onvar : injected -> ground =
    For_gexpr.prjc
      (Tag.prjc (fun _ _ -> assert false))
      (Std.List.prjc prjc (fun _ _ -> assert false))
      (fun _ _ -> assert false)
      onvar

  let constr : Tag.injected -> _ -> injected = eConstr
  let leaf t = constr t (OCanren.Std.nil ())
  let econstr s xs = EConstr (Tag.tag_of_string_exn s, Std.List.of_list id xs)
  let eleaf s = econstr s []
  let pair a b = constr !!(Tag.inttag_of_string_exn "pair") Std.(a %< b)
  let true_ = constr !!(Tag.inttag_of_string_exn "true") Std.(nil ())
  let false_ = constr !!(Tag.inttag_of_string_exn "false") Std.(nil ())

  let height : ground -> int =
    let rec helper (EConstr (_, xs)) =
      GT.foldl Std.List.ground (fun acc x -> max acc (helper x)) 0 xs + 1
    in
    helper

  let show : ground -> string =
    let rec helper pars x =
      match x with
      | EConstr (c, Std.List.Nil) when pars ->
          Printf.sprintf "(%s)" (GT.show Tag.ground c)
      | EConstr (c, Std.List.Nil) -> GT.show Tag.ground c
      | EConstr (s, xs) when pars ->
          Printf.sprintf "(%s %s)" (GT.show Tag.ground s)
            (GT.show Std.List.ground (helper false) xs)
      | EConstr (s, xs) ->
          Printf.sprintf "%s %s" (GT.show Tag.ground s)
            (GT.show Std.List.ground (helper false) xs)
    in
    helper false

  let rec show_logic (x : logic) : string =
    let rec helper x =
      let default s xs =
        Printf.sprintf "EC (%s %s)" (GT.show Tag.logic s)
          (GT.show Std.List.logic show_logic xs)
      in
      match x with
      | EConstr
          ( (Value tag as s),
            (Value
               (Std.List.Cons
                 ( _,
                   Value
                     (Std.List.Cons
                       (_, Value (Std.List.Cons (_, Value Std.List.Nil)))) )) as
            xs) )
        when Tag.of_string_exn "pair" = tag ->
          print_endline "SUSPICIOUS";
          default s xs
      | EConstr (s, xs) -> default s xs
    in

    let ans = GT.show OCanren.logic helper x in
    (* if ans = "" then print_endline "FUCK"; *)
    Format.printf "Expr.show_logic `%s`\n%!" ans;
    ans

  let pp_logic ppf x = Format.fprintf ppf "%s" (show_logic x)

  let rec reify env x =
    For_gexpr.reify OCanren.reify (Std.List.reify reify) env x

  let inject (e : ground) : injected =
    let rec helper = function
      | EConstr (t, xs) ->
          constr (Tag.inject t)
            (inject_ground_list @@ GT.gmap Std.List.ground helper xs)
    in
    helper e

  let logic =
    {
      GT.gcata = ();
      GT.fix = (fun _ -> assert false);
      GT.plugins =
        object
          method fmt = pp_logic
        end;
    }
end

let pwc = WildCard
let __ = pwc

let pconstr name xs =
  PConstr (Tag.tag_of_string_exn name, Std.List.of_list id xs)

let pleaf s = pconstr s []
let pnil = pleaf "nil"
let pnil2 = pleaf "nil2"
let pzero = pleaf "zero"
let ptrue = pleaf "true"
let pfalse = pleaf "false"
let pcons a b = pconstr "cons" [ a; b ]
let psucc a = pconstr "succ" [ a ]
let psome a = pconstr "some" [ a ]
let ppair a b = pconstr "pair" [ a; b ]
let ptriple a b c = pconstr "triple" [ a; b; c ]

(* ************************************************************************** *)

module Matchable = struct
  type ('a1, 'a0) gmatchable = ('a1, 'a0) W.gmatchable =
    | Scru
    | Field of 'a1 * 'a0
  [@@deriving gt ~options:{ foldl; fmt; gmap; compare }]

  type ground = (N.ground, ground) gmatchable
  [@@deriving gt ~options:{ foldl; fmt; gmap; compare }]

  type logic = (N.logic, logic) gmatchable OCanren.logic
  [@@deriving gt ~options:{ foldl; fmt; gmap; compare }]

  type injected = (ground, logic) OCanren.injected

  let scru = scru
  let field = field
  let field0 () = field (z ()) @@ scru ()
  let field1 () = field (s (z ())) @@ scru ()
  let field2 () = field (s (s (z ()))) @@ scru ()
  let field00 () = field (z ()) @@ field0 ()
  let field01 () = field (s (z ())) @@ field0 ()
  let field10 () = field (z ()) @@ field1 ()
  let field11 () : injected = field (s (z ())) @@ field1 ()

  let rec show_logic x =
    let rec helper = function
      | Scru -> "S"
      | Field (n, r) -> Printf.sprintf "%s[%s]" (show_logic r) (N.show_logic n)
    in
    GT.show OCanren.logic helper x

  let show x =
    let rec helper = function
      | Scru -> "S"
      | Field (n, r) -> Printf.sprintf "%s[%s]" (helper r) (N.show n)
    in
    helper x

  let ground =
    {
      GT.gcata = gcata_ground;
      GT.fix = ground.GT.fix;
      GT.plugins =
        object
          method fmt f x = Format.fprintf f "@[%s@]" (show x)
          method show = show
          method gmap = ground.GT.plugins#gmap
          method compare = ground.GT.plugins#compare
        end;
    }

  let logic =
    {
      GT.gcata = gcata_logic;
      GT.fix = logic.GT.fix;
      GT.plugins =
        object
          method fmt f x = Format.fprintf f "@[%s@]" (show_logic x)
          method show = show_logic
          method gmap = logic.GT.plugins#gmap
          method compare = logic.GT.plugins#compare
        end;
    }

  let rec reify env (x : injected) : logic =
    For_gmatchable.reify N.reify reify env x

  let inject : ground -> injected =
   fun root ->
    let rec helper = function
      | Scru -> scru ()
      | Field (n, prev) -> field (N.inject n) (helper prev)
    in
    helper root

  let height_ground m : int =
    GT.transform ground
      (fun fself ->
        object
          inherit [_, _] foldl_ground_t fself
          method m_Scru acc _ = acc + 1
          method m_Field acc _ _ prev = fself (acc + 1) prev
        end)
      0 m

  let to_ground l =
    let rec helper = function
      | Value Scru -> Some Scru
      | Value (Field (n, m)) ->
          N.to_ground n >>=? fun n ->
          helper m >>=? fun m -> Some (Field (n, m))
      | Var (_, _) -> None
    in
    helper l

  let ground_to_list_repr : ground -> N.ground list =
    let rec helper acc = function
      | Scru -> acc
      | Field (n, m) -> helper (n :: acc) m
    in
    helper []

  let low_height_of_logic root =
    let rec helper len = function
      | Value (Field (_, next)) -> helper (len + 1) next
      | Value Scru | Var (_, _) -> len + 1
    in
    let ans = helper 0 root in
    (*      Format.printf "check_scrutinee: length `%s` = %d\n%!" (Matchable.show_logic root) ans;*)
    ans

  module Set = Stdlib.Set.Make (struct
    type t = logic

    let compare = compare
  end)
end

(* ************************************************************************** *)

module IR = struct
  type nonrec ('a3, 'a2, 'a1, 'a0) t = ('a3, 'a2, 'a1, 'a0) W.gir =
    | Fail
    | Switch of 'a3 * 'a2 * 'a1
    | Lit of 'a0
  [@@deriving gt ~options:{ show; fmt; gmap; compare }]

  type ground =
    ( Matchable.ground,
      (Tag.ground, ground) Std.Pair.ground Std.List.ground,
      ground,
      GT.int )
    t
  [@@deriving gt ~options:{ show; fmt; gmap }]

  type logic =
    ( Matchable.logic,
      (Tag.logic, logic) Std.Pair.logic Std.List.logic,
      logic,
      GT.int OCanren.logic )
    t
    OCanren.logic
  [@@deriving gt ~options:{ show; fmt; gmap; compare }]

  type injected = (ground, logic) OCanren.injected

  let fail = fail
  let switch = switch
  let int = lit
  let lit = lit
  let eint n = Lit n

  let rec reify env : injected -> logic =
    For_gir.reify Matchable.reify
      (Std.List.reify @@ Std.Pair.reify Tag.reify reify)
      reify OCanren.reify env

  let fmt f (ir : ground) =
    GT.transform ground
      (fun fself ->
        object
          inherit [_] fmt_ground_t fself
          method! c_Fail fmt _ = Format.fprintf fmt "fail"
          method! c_Lit fmt _ n = Format.fprintf fmt "(Int %d)" n

          method! c_Switch fmt _ m xs on_default =
            Format.fprintf fmt "@[(@[switch %a with @]"
              (GT.fmt Matchable.ground) m;
            GT.foldl Std.List.ground
              (fun () (t, code) ->
                Format.fprintf fmt "@[ | %a -> %a@]" (GT.fmt Tag.ground) t fself
                  code)
              () xs;
            Format.fprintf fmt "@[ | _ -> %a@]" fself on_default;
            Format.fprintf fmt ")@]"
        end)
      f ir

  let show e =
    let (_ : string) = Format.flush_str_formatter () in
    Format.pp_set_margin Format.str_formatter 10000;
    Format.pp_set_max_indent Format.str_formatter
      (Format.pp_get_margin Format.std_formatter () - 1);
    Format.fprintf Format.str_formatter "%a" fmt e;
    Format.flush_str_formatter ()

  let show_ocl f = GT.show OCanren.logic f
  (* let show_ocl_small f = function
     | Value x -> f x
     | Var (n,_) -> Printf.sprintf "_.%d" n*)

  let show_ocl_small = show_ocl (* PRINTING HACK *)

  let rec fmt_logic fmt (e : logic) =
    let fmt_ocl fmt f x = GT.fmt OCanren.logic f fmt x in
    let rec helper fmt = function
      | Fail -> Format.fprintf fmt "fail"
      | Lit ln ->
          Format.fprintf fmt "(Int %a) "
            (GT.fmt OCanren.logic (GT.fmt GT.int))
            ln
      | Switch (m, xs, default) ->
          Format.fprintf fmt "(switch %a with" (GT.fmt Matchable.logic) m;
          GT.foldl Std.List.logic
            (GT.foldl OCanren.logic (fun () (tag, irl) ->
                 Format.fprintf fmt "@[ | %a@ ->@ %a@]" (GT.fmt Tag.logic) tag
                   fmt_logic irl))
            () xs;
          Format.fprintf fmt "@[ | _ -> %a@])" fmt_logic default
    in
    fmt_ocl fmt helper e

  (*
  let rec show_logic e =
    let rec helper = function
    | Fail -> "(fail)"
    | Int ln -> show_ocl_small (GT.show GT.int) ln
    | IFTag (ltag, m, th_, el_) ->
      Printf.sprintf "(iftag %s %s %s %s)"
        (show_ocl (fun s -> Printf.sprintf "\"%s%s\"" (if String.length s = 3 then " " else "") s) ltag)
        (Matchable.show_logic m)
        (show_logic th_)
        (show_logic el_)
    in
    show_ocl_small helper e*)

  let show_logic e =
    let (_ : string) = Format.flush_str_formatter () in
    Format.pp_set_margin Format.str_formatter 10000;
    Format.pp_set_max_indent Format.str_formatter
      (Format.pp_get_margin Format.std_formatter () - 1);
    Format.fprintf Format.str_formatter "%a" fmt_logic e;
    Format.flush_str_formatter ()

  let ground =
    {
      GT.gcata = gcata_ground;
      GT.fix = ground.GT.fix;
      GT.plugins =
        object
          method fmt = fmt
          method show = show
          method gmap = ground.GT.plugins#gmap
        end;
    }

  let logic =
    {
      GT.gcata = gcata_logic;
      GT.fix = logic.GT.fix;
      GT.plugins =
        object
          method fmt = fmt_logic
          method show = show_logic
          method gmap = logic.GT.plugins#gmap
          method show_ast = logic.GT.plugins#show
          method compare = logic.GT.plugins#compare
        end;
    }

  let inject : ground -> injected =
    let rec helper = function
      | Lit n -> int !!n
      | Fail -> fail ()
      | Switch (m, xs, default) ->
          let clauses =
            inject_ground_list
            @@ GT.gmap Std.List.ground
                 (fun (tag, code) ->
                   Std.Pair.pair (Tag.inject tag) (helper code))
                 xs
          in
          switch (Matchable.inject m) clauses (helper default)
    in
    helper

  let count_ifs_ground root =
    GT.transform ground
      (fun fself ->
        object
          method c_Fail acc _ = acc
          method c_Lit acc _ _ = acc

          method c_Switch acc _ _ xs on_default =
            GT.foldl Std.List.ground
              (fun acc (_tag, code) -> fself acc code)
              (fself acc on_default) xs
            + ground_list_length xs
        end)
      0 root

  let count_ifs_low : logic -> int =
   fun root ->
    let rec helper : logic -> int = function
      | Var (_, _) -> 0
      | Value (Lit _) | Value Fail -> 0
      | Value (Switch (_, xs, on_default)) ->
          GT.foldl Std.List.logic
            (fun acc -> function
              | Value (_, code) -> acc + helper code
              | Var _ -> acc)
            (logic_list_len_lo xs) xs
          + helper on_default
    in
    helper root

  let compare_logic a b = GT.compare logic a b
end

module Clauses = struct
  type pg = Pattern.ground * IR.ground
  type pre_ground = pg list
  type ground = pg Std.List.ground
  type logic = (Pattern.logic, IR.logic) Std.Pair.logic Std.List.logic
  type injected = (ground, logic) OCanren.injected

  let inject : pre_ground -> injected =
   fun ps ->
    let rec one : Pattern.ground -> _ = function
      | WildCard -> Pattern.wc ()
      | PConstr (name, ps) ->
          Pattern.constr (Tag.inject name)
          @@ inject_ground_list
          @@ GT.gmap Std.List.ground one ps
    in
    Std.List.list
    @@ List.map (fun (p, rhs) -> Std.Pair.pair (one p) (IR.inject rhs)) ps

  let pretty_print ch clauses =
    Format.fprintf ch "@[match ... with@]@.";
    clauses
    |> List.iter (fun (p, ir) ->
           Format.fprintf ch "@[| %s@ ->@ %s@]@." (Pattern.show p) (IR.show ir))
end

module TagSet = Set.Make (struct
  type t = Tag.ground

  let compare = Caml.compare
end)

module Typs = struct
  type 'a t = 'a W.gtyp_info = T of 'a [@@deriving gt ~options:{ show; fmt }]

  type ground =
    (Tag.ground, ground Std.List.ground) Std.Pair.ground Std.List.ground t
  [@@deriving gt ~options:{ show; fmt }]

  type logic =
    (Tag.logic, logic Std.List.logic) Std.Pair.logic Std.List.logic t
    OCanren.logic

  type injected = (ground, logic) OCanren.injected

  let t eta = W.t eta
  let t_item name xs = Std.Pair.pair name xs

  let rec inject (e : ground) : injected =
    let rec helper : _ -> _ = function
      | s, xs ->
          t_item (Tag.inject s)
            (inject_ground_list @@ GT.gmap Std.List.ground inject xs)
    in
    match e with
    | T xs -> t (inject_ground_list @@ GT.gmap Std.List.ground helper xs)

  let mkt xs : ground = T (Std.List.of_list id xs)

  let get_names (T xs) =
    GT.foldl Std.List.ground
      (fun acc (t, _) -> TagSet.add t acc)
      TagSet.empty xs

  let assoc (T xs) key =
    GT.foldl Std.List.ground
      (fun acc (x, v) ->
        match acc with
        | Some _ as ans -> ans
        | None -> if x = key then Some v else None)
      None xs

  let assoc_exn typs key =
    match assoc typs key with
    | None ->
        failwith
          (Printf.sprintf "Typs.assoc_exn: key '%s' not found in '%s'"
             (GT.show Tag.ground key) (GT.show ground typs))
    | Some x -> x

  type pre_typ = (string * pre_typ list) list t

  let rec construct (root : pre_typ) : ground =
    match root with
    | T xs ->
        mkt
        @@ List.map
             (fun (p, xs) ->
               (Tag.tag_of_string_exn p, Std.List.of_list construct xs))
             xs
end

module Triple = struct
  type ('a, 'b, 'c) ground = 'a * 'b * 'c [@@deriving gt ~options:{ fmt; gmap }]

  module F = Fmap3 (struct
    type ('a, 'b, 'c) t = ('a, 'b, 'c) ground

    let fmap eta = GT.gmap ground eta
  end)

  type nonrec ('a, 'b, 'c) logic = ('a, 'b, 'c) ground OCanren.logic

  let reify fa fb fc = F.reify fa fb fc
  let prjc = F.prjc
  let make x y z = inj @@ F.distrib (x, y, z)
end

module CNames = struct
  type ground = Tag.ground Std.List.ground
  type logic = Tag.logic Std.List.logic
  type injected = (ground, logic) OCanren.injected
end

module Cases = struct
  type ground = (Tag.ground, IR.ground) Std.Pair.ground Std.List.ground
  type logic = (Tag.logic, IR.logic) Std.Pair.logic Std.List.logic
  type injected = (ground, logic) OCanren.injected
end

module EvalMRez = struct
  type ground = (Expr.ground, CNames.ground) Std.Pair.ground

  (*      [@@deriving gt ~options: { show; fmt }]*)
  type logic = (Expr.logic, CNames.logic) Std.Pair.logic

  (*      [@@deriving gt ~options: { show; fmt }]*)
  type injected = (ground, logic) OCanren.injected

  let show x =
    GT.(
      show Std.Pair.ground Expr.show (show Std.List.ground @@ show Tag.ground))
      x

  let show_logic x =
    GT.(
      show Std.Pair.logic Expr.show_logic (show Std.List.logic @@ show Tag.logic))
      x

  let reifier env x =
    Std.Pair.reify Expr.reify (Std.List.reify OCanren.reify) env x
end

type bool_inj = OCanren.Std.Bool.groundi

module type WORK = sig
  val eval_pat :
    Expr.injected ->
    Clauses.injected ->
    (IR.ground, IR.logic) Std.Option.groundi ->
    goal

  val eval_ir :
    Expr.injected ->
    N.injected ->
    Typs.injected ->
    (Matchable.injected ->
    N.injected ->
    Cases.injected ->
    MatchableKind.injected ->
    goal) ->
    (Tag.injected ->
    Matchable.injected ->
    Cases.injected ->
    (Matchable.ground, Matchable.logic) Std.List.groundi ->
    Typs.injected ->
    bool_inj ->
    goal) ->
    (CNames.injected -> Cases.injected -> bool_inj -> goal) ->
    (Tag.injected -> Tag.injected -> bool_inj -> goal) ->
    IR.injected ->
    (int, int OCanren.logic) Std.Option.groundi ->
    goal

  val matchable_leq_nat : Matchable.injected -> N.injected -> bool_inj -> goal

  val not_in_history :
    Matchable.injected ->
    (Matchable.ground, Matchable.logic) Std.List.groundi ->
    bool_inj ->
    goal

  val info_assoc :
    Typs.injected ->
    Tag.injected ->
    (Typs.ground, Typs.logic) Std.List.groundi ->
    goal

  val well_typed_expr : Expr.injected -> Typs.injected -> bool_inj -> goal
end

module WorkHO : WORK = struct
  module Wrap = Work_ho

  let eval_ir :
      (Expr.injected -> goal) ->
      (N.injected -> goal) ->
      (Typs.injected -> goal) ->
      ((Matchable.injected -> goal) ->
      (N.injected -> goal) ->
      ((Tag.ground * IR.ground, _) Std.List.groundi -> goal) ->
      MatchableKind.injected ->
      goal) ->
      (_ -> _ -> _ -> _ -> (Typs.injected -> goal) -> bool_inj -> goal) ->
      (_ -> _ -> _ -> goal) ->
      (_ -> _ -> _ -> goal) ->
      (IR.injected -> goal) ->
      (int, int OCanren.logic) Std.Option.groundi ->
      goal =
    Wrap.eval_ir_o

  let eval_ir e depth typs shct1 shct2 shct3 shct4 ir rez =
    eval_ir (( === ) e) (( === ) depth) (( === ) typs)
      (fun a b c r ->
        Fresh.three (fun a2 b2 c2 ->
            a a2 &&& b b2 &&& c c2 &&& shct1 a2 b2 c2 r))
      (fun a b c d e r ->
        Fresh.five (fun a2 b2 c2 d2 e2 ->
            a a2 &&& b b2 &&& c c2 &&& d d2 &&& e e2 &&& shct2 a2 b2 c2 d2 e2 r))
      (fun a b r -> Fresh.two @@ fun x y -> a x &&& b y &&& shct3 x y r)
      (fun a b r -> Fresh.two @@ fun x y -> a x &&& b y &&& shct4 x y r)
      (( === ) ir) rez

  (*
  let well_typed_expr_height:
    (N.injected -> goal) ->
    (Expr.injected -> goal) ->
    (Expr.injected -> goal) ->
    (Typs.injected -> goal) ->
    bool_inj -> goal
    = Work_base_common.well_typed_expr_height
  *)
  let well_typed_expr_height :
      N.injected ->
      Expr.injected ->
      Expr.injected ->
      Typs.injected ->
      bool_inj ->
      goal =
    (*fun h ed e t r -> Wrap.well_typed_expr_height ((===)h) ((===)ed) ((===)e) ((===)t) r*)
    Work_base_common.well_typed_expr_height

  let well_typed_expr :
      (Expr.injected -> goal) -> (Typs.injected -> goal) -> bool_inj -> goal =
    Wrap.well_typed_expr_o

  let well_typed_expr : Expr.injected -> Typs.injected -> bool_inj -> goal =
   fun e t r -> Wrap.well_typed_expr_o (( === ) e) (( === ) t) r

  let eval_pat s p r = Wrap.eval_pat_o (( === ) s) (( === ) p) r

  let matchable_leq_nat m n r =
    Wrap.matchable_leq_nat_o (( === ) m) (( === ) n) r

  let not_in_history x xs r = Wrap.not_in_history_o (( === ) x) (( === ) xs) r

  let info_assoc typs name rez =
    Wrap.info_assoc_o (( === ) typs) (( === ) name) rez
end

module WorkUnnesting : WORK = Work_unn

(*
let _f ()  =
  run_exn (GT.show Std.Option.ground @@ GT.show GT.int) 1 q qh ("test eval_ir", fun q ->
    eval_ir
      (epair (eleaf "aaa") (eleaf "bbb"))
      (Nat.inject @@ Nat.of_int 2)
      Typs.(inject @@ construct @@ T [ ("pair", [ T [ ("aaa", []) ]; T [ ("bbb", []) ] ]) ])
      simple_shortcut
      (iFTag !!"aab" (field (z()) (scru ())) (int !!1) (int !!2))
      q
  )

let _foo () =
  runR Expr.reify Expr.show Expr.show_logic
        1 q qh ("answers", fun q ->
     eval_ir
        q
        (Nat.inject @@ Nat.of_int 2)
        Typs.(inject @@ construct @@ T [ ("pair", [ T [ ("aab", []) ]; T [ ("bbb", []) ] ]) ])
        simple_shortcut
        (iFTag !!"aab" (field (z()) (scru ())) (int !!1) (int !!2))
        (Std.some (!!2))
  )

let _f () =
  let e1 = Expr.(inject @@ econstr "pair" [ econstr "aab" []; econstr "bbb" [] ]) in
  let t1 = Typs.(inject @@ construct @@ T [ ("pair", [ T [ ("aab", []) ]; T [ ("bbb", []) ] ]) ]) in
  runR EvalMRez.reifier EvalMRez.show EvalMRez.show_logic 1 q qh ("test1 eval_m", fun q ->
     eval_m e1 t1 Matchable.(inject Scru) q
  );
  runR EvalMRez.reifier EvalMRez.show EvalMRez.show_logic 1 q qh ("test1 eval_m", fun q ->
     eval_m e1 t1 Matchable.(inject (Field (Z, Scru))) q
  );

  let open Main_inputs in
  runR EvalMRez.reifier EvalMRez.show EvalMRez.show_logic 1 q qh
    ("test1 S[1][0]", fun q ->
       eval_m
        Expr.(
          let l = econstr "succ" [econstr "succ" [econstr "zero" []]] in
          let r = l in
          inject @@ econstr "pair"  [ l; r ])
        ArgPeanoSimple.typs Matchable.(inject (Field (Z, Field (S Z, Scru)))) q
  );

  ()
*)

let debug_lino line num =
  fresh q
    (debug_var q OCanren.reify (function _ ->
         Format.printf "%s %d\n%!" line num;
         success))

let debug text =
  fresh ()
    (Format.printf "%s\n%!" text;
     success)
