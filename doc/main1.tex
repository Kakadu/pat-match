\documentclass[a5paper,12pt]{article}
\usepackage[cache=true]{minted}
\usepackage{polyglossia}
\setmainlanguage{russian}
\let\cyrillicfonttt\monofamily
\usepackage{comment}
\usepackage{stmaryrd}

\usepackage[ left=1cm
           , right=2cm
           , top=1cm
           , bottom=1.5cm
           ]{geometry}
\usepackage{amssymb,amsmath,amsthm,amsfonts} 

\usepackage{fontspec}
% \DeclareMathSizes{22}{30}{24}{20}

%\usefonttheme{professionalfonts}
\defaultfontfeatures{Ligatures={TeX}}
%\setmainfont[Scale=1.5]{Times New Roman}
%\setmainfont{Latin Modern Roman}
\setmainfont [ Scale=1]{CMU Serif Roman}
\setsansfont[Scale=1]{CMU Sans Serif}

%\setmonofont[ BoldFont=lmmonolt10-bold.otf
%			, ItalicFont=lmmono10-italic.otf
%			, BoldItalicFont=lmmonoproplt10-boldoblique.otf
%			, Scale=1.5
%]{lmmono9-regular.otf}
%\setmonofont[Scale=1.5]{CMU Typewriter Text}
\setmonofont{CMU Typewriter Text}

\usepackage{unicode-math}
\setmathfont{Latin Modern Math}[Scale=1]
\newcommand*{\arr}{\ensuremath{\rightarrow}}

% Doesn't work?
\renewcommand{\epsilon}{\ensuremath{\varepsilon}}
%\renewcommand{\sigma}{\ensuremath{\varsigma}}
\newcommand{\inbr}[1]{\left<{#1}\right>}
\newcommand{\ruleno}[1]{\mbox{[\textsc{#1}]}}
\newcommand{\bigslant}[2]{{\raisebox{.2em}{$#1$}\left/\raisebox{-.2em}{$#2$}\right.}}
\newcommand{\sem}[1]{\llbracket #1 \rrbracket}
\begin{document}

%\begin{minted}[mathescape, escapeinside=??]{ocaml }  
%val encode: term -> heap -> term  (* ??? *)
%
%let encode term ?$\sigma$? = 
%  gmap term (object 
%                method LI h x ?$\arr$? find h x ?$\sigma$? 
%                method Call f ?$\arr$? encode (result_of f) ?$\sigma$? 
%            end)
%
%let find heap x ?$\sigma$? =
%  match heap with 
%  | Defined hs  ?$\arr$? find_defined hs x ?$\sigma$? 
%  | Merge [<?$g_i$?, ?$h_i$?>; ...] ?$\arr$? 
%     UNION [ <encode ?$g_i$? ?$\sigma$?, find ?$h_i$? x ?$\sigma$?>; ...]
%  | RecApp f  ?$\arr$? find (effect_of f) x ?$\sigma$?
%  | h1 ?$\circ$? h2   ?$\arr$? find h2 x (fun x -> find h1 x ?$\sigma$?)
%\end{minted}

\section{Дизъюнктный паттерн мэтчинг}

$$
\mathcal{P = \_ \mid CP^*}
$$

$$
\mathcal{V = CV^*}
$$

$$
\mathcal{S}(p_1,\dots,p_n) = \lambda v \rightarrow \sem{v; p_1,\dots,p_n}
$$

\begin{figure}
  \[
  \begin{array}{cr}
    \inbr{v; \_} \rightarrow 1 & \ruleno{WildCard}\\[2mm]
%    \dfrac{R_i^{k_i}=\lambda\,x_1\dots x_{k_i}\,.\,g}{\inbr{R_i^{k_i}\,(t_1,\dots,t_{k_i}),\sigma,n} \xrightarrow{\circ} \inbr{g\,[\bigslant{t_1}{x_1}\dots\bigslant{t_{k_i}}{x_{k_i}}], \sigma, n}} & \ruleno{Invoke}\\[5mm]
    \dfrac{\inbr{v,p_i}}{\sem{v;p_1,\dots, p_n}} & \ruleno{rule1}\\[5mm]
    \dfrac{\inbr{v_1,p_1},\dots,\inbr{v_n,p_n}}{\inbr{C\ v_1\dots v_n; C\ p_1,\dots, p_n}} & \ruleno{rule2}
%    \\[5mm]
%    \inbr{t_1 \equiv t_2, \sigma, n} \xrightarrow{\circ} \Diamond , \, \, \nexists\; mgu\,(t_1, t_2, \sigma) &\ruleno{UnifyFail} \\[2mm]
%    \inbr{t_1 \equiv t_2, \sigma, n} \xrightarrow{(mgu\,(t_1, t_2, \sigma),\, n)} \Diamond & \ruleno{UnifySuccess} \\[2mm]
%    \inbr{g_1 \lor g_2, \sigma, n} \xrightarrow{\circ} \inbr{g_1, \sigma, n} \oplus \inbr{g_2, \sigma, n} & \ruleno{Disj} \\[2mm]
%    \inbr{g_1 \land g_2, \sigma, n} \xrightarrow{\circ} \inbr{ g_1, \sigma, n} \otimes g_2 & \ruleno{Conj} \\[2mm]
%    \inbr{\mbox{\texttt|fresh|}\, x\, .\, g, \sigma, n} \xrightarrow{\circ} \inbr{g\,[\bigslant{\alpha_{n + 1}}{x}], \sigma, n + 1} & \ruleno{Fresh}\\[2mm]
%    \dfrac{R_i^{k_i}=\lambda\,x_1\dots x_{k_i}\,.\,g}{\inbr{R_i^{k_i}\,(t_1,\dots,t_{k_i}),\sigma,n} \xrightarrow{\circ} \inbr{g\,[\bigslant{t_1}{x_1}\dots\bigslant{t_{k_i}}{x_{k_i}}], \sigma, n}} & \ruleno{Invoke}\\[5mm]
%    \dfrac{s_1 \xrightarrow{\circ} \Diamond}{(s_1 \oplus s_2) \xrightarrow{\circ} s_2} & \ruleno{DisjStop}\\[5mm]
%    \dfrac{s_1 \xrightarrow{r} \Diamond}{(s_1 \oplus s_2) \xrightarrow{r} s_2} & \ruleno{DisjStopAns}\\[5mm]
%    \dfrac{s \xrightarrow{\circ} \Diamond}{(s \otimes g) \xrightarrow{\circ} \Diamond} &\ruleno{ConjStop}\\[5mm]
%    \dfrac{s \xrightarrow{(\sigma, n)} \Diamond}{(s \otimes g) \xrightarrow{\circ} \inbr{g, \sigma, n}}  & \ruleno{ConjStopAns}\\[5mm]
%    \dfrac{s_1 \xrightarrow{\circ} s'_1}{(s_1 \oplus s_2) \xrightarrow{\circ} (s_2 \oplus s'_1)} &\ruleno{DisjStep}\\[5mm]
%    \dfrac{s_1 \xrightarrow{r} s'_1}{(s_1 \oplus s_2) \xrightarrow{r} (s_2 \oplus s'_1)} &\ruleno{DisjStepAns}\\[5mm]
%    \dfrac{s \xrightarrow{\circ} s'}{(s \otimes g) \xrightarrow{\circ} (s' \otimes g)} &\ruleno{ConjStep}\\[5mm]
%    \dfrac{s \xrightarrow{(\sigma, n)} s'}{(s \otimes g) \xrightarrow{\circ} (\inbr{g, \sigma, n} \oplus (s' \otimes g))} & \ruleno{ConjStepAns} 
  \end{array}
  \]
  \caption{Non-deterministic semantioc of disjunctive pattern matching}
%  \label{lts}
\end{figure}


\section{Промежуточное представление}
\begin{align*}
\mathcal{C} &= \{ C_1^{k_1}, \dots, C_n^{k_n} \} \\
\mathcal{M} =&\;  \mathcal{S} \\
          \mid\; &\; \text{\texttt{field}}\  \mathcal{M}\  \mathbb{N}\\
\mathcal{IR} =&\; \mathcal{S} \\
           \mid\; &\;\text{\texttt{Int}}\  \mathbb{N} \\
           \mid\; &\;\text{\texttt{Expr}}\  \mathcal{V} \\
           \mid\; &\; \text{\texttt{IfTag}}\; \mathcal{C}\; \mathcal{M}\; \mathcal{I\!R}\; \mathcal{I\!R}
\end{align*}
Скомпилированная программа на основе паттернов $p_1,\dots,\_n$ -- это 
такие программы $pr$, что 

$$
\forall s.\; eval_{\mathcal{I\!R}}\; pr\; s = \sem{s;p_1\dots,p_n} 
$$
или в реляционном синтаксисе

$$
\forall s \exists\; res.\; (eval^o_{\mathcal{I\!R}}\; pr\; s res) \land ( res = \sem{s;p_1\dots,p_n}) 
$$

\end{document}
