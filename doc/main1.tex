\documentclass[a5paper,12pt]{article}
\usepackage[cache=true]{minted}
\usepackage{polyglossia}
\setmainlanguage{russian}
\let\cyrillicfonttt\monofamily
\usepackage{comment}
\usepackage{stmaryrd}

\usepackage[ left=1cm
           , right=2cm
           , top=1cm
           , bottom=1.5cm
           ]{geometry}
\usepackage{amssymb,amsmath,amsthm,amsfonts} 

\usepackage{fontspec}
% \DeclareMathSizes{22}{30}{24}{20}

%\usefonttheme{professionalfonts}
\defaultfontfeatures{Ligatures={TeX}}
%\setmainfont[Scale=1.5]{Times New Roman}
%\setmainfont{Latin Modern Roman}
\setmainfont [ Scale=1]{CMU Serif Roman}
\setsansfont[Scale=1]{CMU Sans Serif}

%\setmonofont[ BoldFont=lmmonolt10-bold.otf
%			, ItalicFont=lmmono10-italic.otf
%			, BoldItalicFont=lmmonoproplt10-boldoblique.otf
%			, Scale=1.5
%]{lmmono9-regular.otf}
%\setmonofont[Scale=1.5]{CMU Typewriter Text}
\setmonofont{CMU Typewriter Text}

\usepackage{unicode-math}
\setmathfont{Latin Modern Math}[Scale=1]
\newcommand*{\arr}{\ensuremath{\rightarrow}}

% Doesn't work?
\renewcommand{\epsilon}{\ensuremath{\varepsilon}}
%\renewcommand{\sigma}{\ensuremath{\varsigma}}
\newcommand{\inbr}[1]{\left<{#1}\right>}
\newcommand{\ruleno}[1]{\mbox{[\textsc{#1}]}}
\newcommand{\bigslant}[2]{{\raisebox{.2em}{$#1$}\left/\raisebox{-.2em}{$#2$}\right.}}
\newcommand{\sem}[1]{\llbracket #1 \rrbracket}
\begin{document}

\begin{minted}[mathescape, escapeinside=??]{ocaml }  
val encode: term -> heap -> term  (* ??? *)

let encode term ?$\sigma$? = 
  gmap term (object 
                method LI h x ?$\arr$? find h x ?$\sigma$? 
                method Call f ?$\arr$? encode (result_of f) ?$\sigma$? 
            end)

let find heap x ?$\sigma$? =
  match heap with 
  | Defined hs  ?$\arr$? find_defined hs x ?$\sigma$? 
  | Merge [<?$g_i$?, ?$h_i$?>; ...] ?$\arr$? 
     UNION [ <encode ?$g_i$? ?$\sigma$?, find ?$h_i$? x ?$\sigma$?>; ...]
  | RecApp f  ?$\arr$? find (effect_of f) x ?$\sigma$?
  | h1 ?$\circ$? h2   ?$\arr$? find h2 x (fun x -> find h1 x ?$\sigma$?)
\end{minted}

\section{Дизъюнктный паттерн мэтчинг}

$$
\mathcal{P = \_ \mid CP^*}
$$

$$
\mathcal{V = CV^*}
$$

...
$\llbracket a+b\rrbracket$

\begin{figure}
  \[
  \begin{array}{cr}
    \inbr{v; \_} \rightarrow 1 & \ruleno{WildCard}\\[2mm]
%    \dfrac{R_i^{k_i}=\lambda\,x_1\dots x_{k_i}\,.\,g}{\inbr{R_i^{k_i}\,(t_1,\dots,t_{k_i}),\sigma,n} \xrightarrow{\circ} \inbr{g\,[\bigslant{t_1}{x_1}\dots\bigslant{t_{k_i}}{x_{k_i}}], \sigma, n}} & \ruleno{Invoke}\\[5mm]
    \dfrac{\inbr{v,p_i}}{\sem{v;p_1,\dots, p_n}} & \ruleno{rule1}\\[5mm]
    \dfrac{\inbr{v_1,p_1},\dots,\inbr{v_n,p_n}}{\inbr{C\ v_1\dots v_n; C\ p_1,\dots, p_n}} & \ruleno{rule2}
%    \\[5mm]
%    \inbr{t_1 \equiv t_2, \sigma, n} \xrightarrow{\circ} \Diamond , \, \, \nexists\; mgu\,(t_1, t_2, \sigma) &\ruleno{UnifyFail} \\[2mm]
%    \inbr{t_1 \equiv t_2, \sigma, n} \xrightarrow{(mgu\,(t_1, t_2, \sigma),\, n)} \Diamond & \ruleno{UnifySuccess} \\[2mm]
%    \inbr{g_1 \lor g_2, \sigma, n} \xrightarrow{\circ} \inbr{g_1, \sigma, n} \oplus \inbr{g_2, \sigma, n} & \ruleno{Disj} \\[2mm]
%    \inbr{g_1 \land g_2, \sigma, n} \xrightarrow{\circ} \inbr{ g_1, \sigma, n} \otimes g_2 & \ruleno{Conj} \\[2mm]
%    \inbr{\mbox{\texttt|fresh|}\, x\, .\, g, \sigma, n} \xrightarrow{\circ} \inbr{g\,[\bigslant{\alpha_{n + 1}}{x}], \sigma, n + 1} & \ruleno{Fresh}\\[2mm]
%    \dfrac{R_i^{k_i}=\lambda\,x_1\dots x_{k_i}\,.\,g}{\inbr{R_i^{k_i}\,(t_1,\dots,t_{k_i}),\sigma,n} \xrightarrow{\circ} \inbr{g\,[\bigslant{t_1}{x_1}\dots\bigslant{t_{k_i}}{x_{k_i}}], \sigma, n}} & \ruleno{Invoke}\\[5mm]
%    \dfrac{s_1 \xrightarrow{\circ} \Diamond}{(s_1 \oplus s_2) \xrightarrow{\circ} s_2} & \ruleno{DisjStop}\\[5mm]
%    \dfrac{s_1 \xrightarrow{r} \Diamond}{(s_1 \oplus s_2) \xrightarrow{r} s_2} & \ruleno{DisjStopAns}\\[5mm]
%    \dfrac{s \xrightarrow{\circ} \Diamond}{(s \otimes g) \xrightarrow{\circ} \Diamond} &\ruleno{ConjStop}\\[5mm]
%    \dfrac{s \xrightarrow{(\sigma, n)} \Diamond}{(s \otimes g) \xrightarrow{\circ} \inbr{g, \sigma, n}}  & \ruleno{ConjStopAns}\\[5mm]
%    \dfrac{s_1 \xrightarrow{\circ} s'_1}{(s_1 \oplus s_2) \xrightarrow{\circ} (s_2 \oplus s'_1)} &\ruleno{DisjStep}\\[5mm]
%    \dfrac{s_1 \xrightarrow{r} s'_1}{(s_1 \oplus s_2) \xrightarrow{r} (s_2 \oplus s'_1)} &\ruleno{DisjStepAns}\\[5mm]
%    \dfrac{s \xrightarrow{\circ} s'}{(s \otimes g) \xrightarrow{\circ} (s' \otimes g)} &\ruleno{ConjStep}\\[5mm]
%    \dfrac{s \xrightarrow{(\sigma, n)} s'}{(s \otimes g) \xrightarrow{\circ} (\inbr{g, \sigma, n} \oplus (s' \otimes g))} & \ruleno{ConjStepAns} 
  \end{array}
  \]
  \caption{Non-deterministic semantioc of disjunctive pattern matching}
%  \label{lts}
\end{figure}

\subsection{Пример из статьи}

\textbf{N.B.} В статье такой язык, где функции не возвращают содержательного результата, т.е. имеют тип \mintinline{ocaml}{unit}. Иными словами, содержательное поведение функции -- это её эффект на глобальном состояии. Наверное можно немного изменить, чтобы поддержать содержательные результаты функции, но пока хз как.

Используется функция $SAT(Env, Rec(f), Phormula)$, которая означает что в контексте результатов символьного исполнения $Env$ после запуска функции $f$ не случается $Assert(Phormula)$, иными словами, после исполнения $f$ на произвольных аргументах формула не выполнима.

Там есть типа алгоритм
\begin{enumerate}
  \item Нормализация $e$ и преобразование трёх верхнеуровневого объединения в конструкцию ветвления.
  \item Замена ячеек $LI(\sigma,x)$  на  $find(\sigma, x, \tau)$.
  \item Специализация $find$ согласно правилам.
\end{enumerate}

Например, надо проверить $SAT(Env, Rec(f), LI(\varepsilon, a) * 3< 17)$ при $Body(f) = $
$merge(<c,\varepsilon>, <\neg c, \sigma \circ Rec(f)>)$, т.е. ограничение 
$g = (Rec(f)\bullet LI(\varepsilon,a)*3<17) = (LI(Rec(f), a)*3 < 17)$ при некоторых наперед заданных $a$, $c$ и $\sigma$.

Контекст, в котором происходит первый вызов $f$ будем обозначать $\tau_0$.

Избавляемся от $LI$: $g = (find(Rec(f), a, \tau_0)*3 < 17)$

Третий шаг порождает специализацию $find_f$, а закодированная формула становится 
$g = (find_f\ \tau_0\ a)*3 < 17$.

Теперь надо описать функцию $find_f\ \tau\ x = ... $ Тело получается применением шагов 1-3 к $Body(f)$: 

\begin{center}
$find( merge(<c,\varepsilon>, <\neg c, \sigma \circ Rec(f)>),\ x,\ \tau)$ = 
 $ite(\tau\bullet c,\ find(\varepsilon,x,\tau),\ find(\sigma\circ Rec(f),x,\tau)$
\end{center}
Здесь получаются два $find$, которые надо специализировать.

$find_{\varepsilon} \tau\ x = \tau\ x$

$find_{\sigma\circ\ Rec(f)}\ \tau\ x = find_{f}\ (find_{\sigma}\ \tau)\ x$

Функция $find_\sigma$ задана свыше, так как $\sigma$ задана свыше.

\subsection{Фибоначчи самый наивный}
\begin{minted}{ocaml}  
let rec fib1 n = 
  if n <=1 then 1
  else if n <= 2 then 1
  else (fib1 (n-1)) + (fib1 (n-2))
\end{minted}

После символьного исполнения получается пустой эффект и терм:
\begin{minted}[mathescape, escapeinside=??]{ocaml}
effect_of(?$fib_{1002}$?) = ?$\varepsilon$?
result_of(?$fib_{1002}$?) = 
  Union 
    [ ?$(n_{1003} \leqslant 1, \quad 1) $?
    ; ?$(n_{1003} > 1 \wedge n_{1003} \leqslant 2,\quad 1)$?
    ; ?$(n_{1003} > 1 \wedge n_{1003} > 2$?
      , (Call (Ident ?$fib_{1002}$?) ?$\{n_{1003} \mapsto n_{1003} - 2\}$? +
        (Call (Ident ?$fib_{1002}$?) ?$\{n_{1003} \mapsto n_{1003} - 2\}  )$?   
    ]
\end{minted}
Упрощение
\begin{minted}[mathescape, escapeinside=??]{ocaml}
effect_of(?$fib_{1002}$?) = ?$\varepsilon$?
result_of(?$fib_{1002}$?) = 
  Union 
    [ ?$(n_{1003} \leqslant 2, \quad 1)$?
    ; ?$(n_{1003} > 2 $?
      , (Call (Ident ?$fib_{1002}$?) ?$\{n_{1003} \mapsto n_{1003} - 2\}$?) +
        (Call (Ident ?$fib_{1002}$?) ?$\{n_{1003} \mapsto n_{1003} - 2\} $?) ?$)$?

    ]
\end{minted}
Теперь свойство, от которого будем доказывать: 
\begin{minted}[mathescape, escapeinside=??]{ocaml}
?$\forall n . (n \geqslant 1) \Rightarrow$? (Call (Ident ?$fib_{1002}$?) ?$\{n_{1003} \mapsto n\}$?) ?$\geqslant n$?
\end{minted}

Сейчас хотим специализировать \mintinline{latex}{find} для \mintinline{latex}{fib1}, избавляясь по дороге от композиций куч и LI.

\begin{minted}[mathescape, escapeinside=??]{ocaml}
encode ((Call (Ident ?$fib_{1002}$?) ?$\{n_{1003}\ \mapsto n\}$?))), ?$\sigma$?)
encode ( (result_of ?$fib_{1002}$?) ?$\{n_{1003}\ \mapsto n\}$?})) ), ?$\sigma$?)

let encoded_fib ?$\{ n_{1003}\ \mapsto\ n_{1003}\}$? = 
    if ?$n_{1003} \leqslant 2$? then ?$1$?
    else 
        encoded_fib ?$\{ n_{1003}\ \mapsto\ (n_{1003} - 1)\}$? +  
        encoded_fib ?$\{ n_{1003}\ \mapsto\ (n_{1003} - 2)\}$?
\end{minted}


% \begin{minted}[mathescape, escapeinside=??]{ocaml}
% ?$\forall n . (n \geqslant 1) \Rightarrow$? find (Call (LI ("fib1_1002")), ?$n$?, WTF) ?$\geqslant n$?
% 
% ?$\forall n . (n \geqslant 1) \Rightarrow$? find (effect_of("fib1_1002"), ?$n$?, WTF) ?$\geqslant n$?
% 
% ?$\forall n . (n \geqslant 1) \Rightarrow$? find (?$\varepsilon$?, ?$n$?, WTF) ?$\geqslant n$?
% 
% ?$\forall n . (n \geqslant 1) \Rightarrow$? (find_defined ?$\varepsilon$?  ?$n$? WTF) ?$\geqslant n$?
% \end{minted}

\subsection{Фибоначчи императивный}
\begin{minted}{ocaml}  
let a = ref 0
let b = ref 0

let rec loop n = 
  if n <= 1
  then ()
  else 
    let c  = !a + !b in 
    let () = a := !b in
    b := c;
    loop (n-1) 
 
let fib ndx = 
  a := 1;
  b := 1;
  loop ndx;
  !b
\end{minted}
% Может для полноты ещё написать для a и b
После символьного исполнения $loop_{1635}$ и упрощения $a \neq b \wedge c \neq a \wedge c \neq b$
\begin{minted}[mathescape, escapeinside=??]{ocaml}
effect_of(?$loop_{1635}$?) = HMerge 
  [ (?$n_{1636} \leqslant 1$?, ?$\varepsilon$?)
  ; (?$n_{1636} > 1$?,
      [ (?$b_{1634} \mapsto (a_{1002} + b_{1634})$?)
      ; (?$c_{1637} \mapsto (a_{1002} + b_{1634})$?)
      ; (?$a_{1002} \mapsto b_{1634}$?)          
      ] ?$\circ$? (RecApp ?$loop_{1635}$? ?$\{n_{1636} \mapsto n_{1636} - 1\}$?)
    )
  ]
result_of(?$loop_{1635}$?) = Union 
  [ ( ?$n_{1636} \leqslant$? 1, Unit)     
  ; ( ?$n_{1636} >$? 1,
      Call (Ident ?$loop_{1635}$?) ?$\{n_{1003} \mapsto (n_{1003} - 1)\}$?) )
  ]
\end{minted}
После символьного исполнения $fib_{1638}$
\begin{minted}[mathescape, escapeinside=??]{ocaml}
effect_of(?$fib_{1638}$?) = 
  ?$\{ b_{1634} \mapsto 1;\quad a_{1002} \mapsto 1\} \ \circ$? (RecApp (Ident ?$ loop_{1635}) \ \{ n_{1636} \mapsto ndx_{1639} \}$?)
result_of(?$fib_{1638}$?) = ?$b_{1634}$? 
\end{minted}

Теперь свойство, от которого будем доказывать: 
\begin{minted}[mathescape, escapeinside=??]{ocaml}
?$\forall n . (n \geqslant 1) \Rightarrow$? (Call (Ident ?$fib_{1638}$?) ?$\{n_{1003} \mapsto ndx_{1639}\}$?) ?$\geqslant n$?
\end{minted}

В терминах функции SAT: $SAT(Body, Rec(loop_{1635}), b_{1638} \leqslant n_{1003})$. Другими словами, после выполнения функции $loop_{1635}$ на куче $\tau_0=\{a\mapsto 1, b\mapsto 1, ndx\mapsto n\}$ формула $b_{1638} \leqslant n_{1003}$ будет невыполнима.

Поехали. Нужно проверять $g = (Rec(loop)\bullet LI(\varepsilon, b) > n)$.

Пихаем композицию внутрь:  $(LI(Rec(loop), b) > n)$.

Вводим find: $find(Rec(loop), b, \tau_0) > n$.

Порождаем специализацию $find_{loop}\ \tau\ x = ...$ и получаем формулу $find_{loop}\  \tau_0\ b > n$.

Теперь надо специализровать тело функции $loop$. 
\begin{center}
	$find()$
\end{center}



\begin{minted}[mathescape, escapeinside=??]{ocaml}


encode (Call (Ident ?$fib_{1638}$?)) ?$\{n_{1003}\ \mapsto n\}$? = 
encode (   result_of ?$fib_{1638}$?) ?$\{n_{1003}\ \mapsto n\}$?


let encoded_fib ?$\{ n_{1003}\ \mapsto\ n_{1003}\}$? = 
    if ?$n_{1003} \leqslant 2$? then ?$1$?
    else 
        encoded_fib ?$\{ n_{1003}\ \mapsto\ (n_{1003} - 1)\}$? +  
        encoded_fib ?$\{ n_{1003}\ \mapsto\ (n_{1003} - 2)\}$?
\end{minted}
\end{document}
