% !TEX TS-program = xelatex
% !TeX spellcheck = en_US
% !TEX root = wildcards.tex
\documentclass[aspectratio=169
  , xcolor={svgnames}
  , hyperref=
      { colorlinks
      , urlcolor=DarkBlue
      }
  , russian  % This line affects translation of theorem titles
  ]{beamer}
\usepackage[svgnames]{xcolor}
\usetheme{CambridgeUS}
\usefonttheme{professionalfonts}


\input{heading}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Wildcards Logic Variables}

\date{  Thu 15 Sep 2022}

\author
  [\textbf{Dmitrii Kosarev}, Daniil Berezun, Peter Lozov]
  {\textbf{Dmitrii Kosarev}$^1$, Daniil Berezun$^2$, Peter Lozov$^1$}
\institute[]{St. Petersbur State University, Russia$^1$ \and JetBrains Research, The Netherlands$^2$}


\AtBeginSection[]
{
  \begin{frame}<beamer>
    \frametitle{Оглавление}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}

\newcommand{\verbatimfont}[1]{\def\verbatim@font{#1}}
\usepackage{verbatimbox}

%\setbeamertemplate{section in toc}{\inserttocsectionnumber.~\inserttocsection}
\begin{document}
\maketitle

% For every picture that defines or uses external nodes, you'll have to
% apply the 'remember picture' style. To avoid some typing, we'll apply
% the style to all pictures.
%\tikzstyle{every picture}+=[remember picture]

% By default all math in TikZ nodes are set in inline mode. Change this to
% displaystyle so that we don't get small fractions.
\everymath{\displaystyle}

% Uncomment these lines for an automatically generated outline.
\begin{frame}{В этих слайдах}


\begin{itemize}
  \item Interpeters, deseq in Scheme
  \item diseq in OCanren
  \item How wildcards work
  \item Peano example
  \item noCanren example
  \item mathcing example
\end{itemize}
\end{frame}

\defverbatim[colored]{\schemeInterpreter}{
\begin{minted}{scheme}
; Scheme
(define eval-exp-o
 (lambda (exp env val)
  (conde
     ...
     (== `(quote ,v) exp)
     ...
     (== `(list . ,a*) exp)
     ...
     (== `(,rator ,rand) exp)
     ...
     (== `(lambda (,x ) ,body) exp)
     ...
\end{minted}
}

\begin{frame}{A reminder of relational interpeters...}
\framesubtitle{William E. Byrd et al. \miniKanren{}, Live and Untagged: Quine Generation via Relational Interpreters. 2012}
\begin{figure}[t]
\begin{subfigure}{.49\textwidth}
\begin{minipage}{.4\textwidth}
\schemeInterpreter
\end{minipage}
\end{subfigure}
\hskip1em
\begin{subfigure}[ht]{.4\textwidth}
Question: how to say that expression \mintinline{scheme}|q| doesn't fit the first case (is not a quote expression)? 
\begin{itemize}
\item \mintinline{scheme}|fresh (v) (=/= q `(quote , v))|
\end{itemize}

It's possible because data representation specifies 
\begin{itemize}
\item arity first 
\item fillment of a list later
\end{itemize}
\end{subfigure}
\end{figure}
\footnote{}
\end{frame}

\defverbatim[colored]{\XXX}{
\begin{minted}{ocaml}
(* very much simplified *)
type exp = 
  | Quote of exp
  | List of exp list 
  | Appl of exp * exp
  | Lam of var * exp * exp
  | ...
\end{minted}
}
\defverbatim[colored]{\BuggyIneq}{
\begin{minted}{ocaml}
(* not quite a solution*)
fresh (v) (q =/= quote v)
\end{minted}
}
\begin{frame}{\OCanren{} uses different representation of values}
\begin{figure}[ht]
\begin{subfigure}[t]{.45\textwidth}
\begin{minipage}{.4\textwidth}
\XXX
\end{minipage}
In \OCanren{} we specify constructor \emph{first} and arity and args \emph{later}
\end{subfigure}\hskip2em
\begin{subfigure}[ht]{.49\textwidth}
  Question: how to say that expression \mintinline{scheme}|q| doesn't fit the first case (is not a quote expression)? 
  \begin{itemize}
  \item \begin{minipage}{.4\textwidth}
        \BuggyIneq
        \end{minipage}
  \end{itemize}
        We said: exists v that q is not quote v 
        
        We wanted q is not quote v for any possible v 
        
        In other words: $\forall$ v: \mlinline{q =/= quote v}
\end{subfigure}
\end{figure}
\footnote{}
\end{frame}

\begin{frame}
\begin{itemize}
\item It may look like too specific for relational interpreters...
\item ... or to \OCanren{} itself
\item But we managed to found an example, that make sense bot for \Scheme{} \miniKanren{} and \OCanren{} implemented in \OCaml{}
\end{itemize}

TODO: contributions?
\end{frame}

\begin{frame}{Example with Peano numbers}

What would be solutions for q, that is not equal \mintinline{scheme}{(s (s (s ,v))))} for any possible v?

\begin{itemize}
\item[\faGood] \mintinline{scheme}{z}
\item[\faGood] \mintinline{scheme}{(s z)}
\item[\faGood] \mintinline{scheme}{(s (s z))}
\item[\faBad] \mintinline{scheme}{(s (s (s z)))}
\item[\faBad] \mintinline{scheme}{(s (s (s (s z))))}
\item[\faBad] \mintinline{scheme}{(s (s (s (s (s z)))))}
\item ...
\item All peano numbers less than three fit, others doesn't.
\end{itemize}

\end{frame}
\begin{frame}{Contributions}
\begin{enumerate}


\item Wildcard Logic Variables
\begin{itemize}
\item Are able to express "Peano number \emph{less} than constant N"
\item Previously, we could only do "Peano number \emph{greater} than constant N"
\end{itemize}
\item An application to \noCanren{} -- more expressivity
\item Work in progress application to pattern-matching synthesis.
\end{enumerate}
\end{frame}

\begin{frame}{Implementation Sketch}
We introduce a special \emph{wildcard variables} (denoted by two underscores: \mlinline{__}) and 

\begin{itemize}
\item \emph{modify unification}: wildcards unify with everything but don't extend current substitution
\item disequality constraints doesn't change significantly
\end{itemize} 
%\begin{figure}[ht]
%\begin{subfigure}[t]{.45\textwidth}
%
%\end{subfigure}\hskip1em
%\begin{subfigure}[t]{.45\textwidth}
\vskip1em
Examples:
\begin{itemize}
\item  \mlinline{(1 _.10) =/= (__ 2)} $\rightsquigarrow$
  \mlinline{_.10 =/= 2}
\item \mlinline{cons __  __  =/= _.10 &&} \mlinline{cons _.11 _.12 === _.10   } 
$\rightsquigarrow$ fail
\item A fresh variable \mlinline{_.10 =/= __}. \\
If a variable has non-empty domain, it should fail. For empty domain -- success
\end{itemize}

%\begin{itemize}
%\item \emph{modify unification}: wildcards unify with everything but don't extend current substitution
%\item disequality constraints doesn't change significantly
%\end{itemize}

%\end{subfigure}
%\end{figure}


\end{frame}


\begin{frame}{Related Works}
\begin{enumerate}
\item Eigen variables\footnote{1}
\begin{itemize}
\item Universal quantifier inside unification, disequality constraints support is shaky
\end{itemize}
\item Universal Quantification and Implication\footnote{2}
%\begin{itemize}
%\item Looks promising 
%\end{itemize}
\end{enumerate}
\end{frame}

\begin{frame}{An application: \noCanren}
\begin{itemize}
\item [\faBad] \miniKanren{} requires some time to study (as any language/DSL)
\item An idea: synthesize relational code from a subset of general purpose language (for example, \OCaml{})\footnote{Lozov 2017}
\begin{itemize}
\item[\faGood] Typechecker for free
\item[\faGood] Convenient \OCaml{}-like syntax  for free (at least it should be  )
\item Semantics preserving transformation to miniKanren is proved on paper
\end{itemize}
\item  Restrictions on subset of \OCaml{} are quite strong
\begin{itemize}
\item Some langauge features are not avaialble (pattern matching guards)
\item Some \OCaml{} best practices hurt performance
\item Overlapping patterns in pattern matching are banished\\
But wildcard variables will help with that \faGood

\end{itemize}
\end{itemize}
\end{frame}

\defverbatim[colored]{\lozovMLexOne}{
\begin{minted}{ocaml}
(* LozovML *)
match x, y with
| T, _ -> 1
| _, _ -> 2
\end{minted}
}
\defverbatim[colored]{\straightforwardCompilation}{
\begin{minted}{ocaml}
(* OCanren *)
let straightforward q rez =
  conde
    [ fresh ()
        (rez === !!1)
        (q === Std.pair !!true __)
    ; fresh (l r)
        (rez === !!2)
        (q === Std.pair l r)
    ]
\end{minted}
}
\defverbatim[colored]{\naiveCompilation}{
\begin{minted}{ocaml}
(* OCanren *)
let naive_rel q rez =
  conde
    [ fresh (tmp)
        (q === pair !!true tmp)
        (rez === !!1)
    ; fresh (tmp l r)
        (q =/= pair !!true tmp)
        (q === pair l r)
        (rez === !!2)
    ]
\end{minted}
}

\defverbatim[colored]{\betterCompilation}{
\begin{minted}{ocaml}
(* OCanren *)
let better_rel q rez =
  conde
    [ fresh ()
        (q === pair !!true __)
        (rez === !!1)
    ; fresh ()
        (q =/= pair !!true __)
        (rez === !!2)
    ]
\end{minted}
}

\begin{frame}[fragile]{ }
\begin{figure}[ht]
\begin{subfigure}[t]{.25\textwidth}
  \begin{minipage}{1\textwidth}
  Overlapping patterns are banned, let's see what could go wrong...
  \lozovMLexOne
  \end{minipage}
\end{subfigure}\hskip3em
\begin{subfigure}[t]{.55\textwidth}
\only<1>{
  \begin{minipage}{.55\textwidth}
  \straightforwardCompilation
  \end{minipage}
  \begin{itemize}
  \item [\faBad] no restrictions between matching branches, can ``return'' for \mlinline{(q===Std.pair !!true !!true)} both 1 and 2
  \end{itemize}  
}
\only<2>{
  \begin{minipage}{.45\textwidth}
  \naiveCompilation
  \end{minipage}
  \begin{itemize}
  \item [\faBad] Restrictions established by default disequality constraints are not powerful enough\\
  
  For \mlinline{fresh (v) (q === Std.pair !!true v)} both 1 and 2m because variable \mlinline{tmp} is existential
    \end{itemize}
}
\only<3>{
  \begin{minipage}{.45\textwidth}
  \betterCompilation
  \end{minipage}
  \begin{itemize}
  \item [\faGood] if \mlinline{fresh (v) (q === Std.pair !!true v)} it gives 1 and doesn't give 2 (which is expected)
    \end{itemize}
}
\end{subfigure}
\end{figure}

\end{frame}

\begin{frame}{Something about Pattern matching}
content
\end{frame}



\begin{frame}{}
Some technical details about typing and wildcards in unification
\end{frame}



\begin{frame}{Итоги}
Новые понятия
\begin{enumerate}
\item каррированные функции
\item вложенные функции
\item сопоставление с образцом и wildcard
\item хвостовая рекурсия
\item автоматический вывод типов
\item разделение на файлы интерфейса и реализации
\end{enumerate}
\end{frame}

\begin{frame}[allowframebreaks]
\frametitle<presentation>{Ссылки}
\begin{thebibliography}{10}
  \bibitem{blow}
    Предотвращая коллапс цивилизации (Preventing the Collapse of Civilization), 2019 (in English)
    \newblock {\em Jonathan Blow}
    \newblock\href{https://youtu.be/pW-SOdj4Kkk}{YouTube}
  \bibitem{cheatsheets}
    Шпаргалки по синтаксису OCaml
    \newblock {\em OCamlPro}
    \newblock\href{https://ocaml.org/docs/cheat_sheets.html}{4 PDF online}
  \bibitem{rwo}
    Книга Real World OCaml издания 2.0 (есть русский перевод издания 1.0)
    \newblock\href{https://dev.realworldocaml.org/toc.html}{online}
  \bibitem{javaTuringComplete}
    Java Generics are Turing Complete
    \newblock {\em Radu Grigore}
    \newblock\href{https://arxiv.org/pdf/1605.05274}{online}
  \bibitem{algDThistory}
    A Brief History of Algebraic Data Types
    \newblock {\em Li-yao Xia}
    \newblock\href{https://docs.google.com/presentation/d/131_CYsd9mEL-0XqXMyV7JeahWgtNCUV_JwjH7WqYFcI/edit}{online}
\end{thebibliography}
\end{frame}


\end{document}
