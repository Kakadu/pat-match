% !TEX TS-program = xelatex
% !TeX spellcheck = en_US
% !TEX root = wildcards.tex
\documentclass[aspectratio=169
  , xcolor={svgnames}
  , hyperref=
      { colorlinks
      , urlcolor=DarkBlue
      }
  , russian  % This line affects translation of theorem titles
  ]{beamer}
\usepackage[svgnames]{xcolor}
\usetheme{CambridgeUS}
\usefonttheme{professionalfonts}


\input{heading}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Wildcards Logic Variables}
\subtitle{How to say in miniKanren that natural number is less than 5?}

\date{  Thu 15 Sep 2022}

\author
  [\textbf{Dmitrii Kosarev}, Daniil Berezun, Peter Lozov]
  {\textbf{Dmitrii Kosarev}$^1$, Daniil Berezun$^2$, Peter Lozov$^1$}
\institute[]{St. Petersbur State University, Russia$^1$ \and JetBrains Research, The Netherlands$^2$}


\AtBeginSection[]
{
  \begin{frame}<beamer>
    \frametitle{Оглавление}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}

\newcommand{\verbatimfont}[1]{\def\verbatim@font{#1}}
\usepackage{verbatimbox}

%\setbeamertemplate{section in toc}{\inserttocsectionnumber.~\inserttocsection}
\begin{document}
\maketitle

% For every picture that defines or uses external nodes, you'll have to
% apply the 'remember picture' style. To avoid some typing, we'll apply
% the style to all pictures.
%\tikzstyle{every picture}+=[remember picture]

% By default all math in TikZ nodes are set in inline mode. Change this to
% displaystyle so that we don't get small fractions.
\everymath{\displaystyle}

%\begin{frame}{В этих слайдах}
%
%
%\begin{itemize}
%  \item Interpeters, deseq in Scheme
%  \item diseq in OCanren
%  \item How wildcards work
%  \item Peano example
%  \item noCanren example
%  \item mathcing example
%\end{itemize}
%\end{frame}

\defverbatim[colored]{\schemeInterpreter}{
\begin{minted}{scheme}
; Scheme
(define eval-exp-o
 (lambda (exp env val)
  (conde
     ...
     (== `(quote ,v) exp)
     ...
     (== `(list . ,a*) exp)
     ...
     (== `(,rator ,rand) exp)
     ...
     (== `(lambda (,x ) ,body) exp)
     ...
\end{minted}
}

\defverbatim[colored]{\hackOne}{
\begin{minted}{scheme}
fresh (v)
  (=/= q `(quote ,v))
\end{minted}
}

\begin{frame}{A Reminder of Relational Interpreters...}
\framesubtitle{}
\begin{figure}[t]
\begin{subfigure}{.49\textwidth}
\begin{minipage}{.4\textwidth}
\schemeInterpreter
\end{minipage}
\end{subfigure}
\hskip3em
\begin{subfigure}[ht]{.4\textwidth}
Question: how to say that expression \mintinline{scheme}|q| doesn't fit the first case (is not a quote expression)?

\begin{minipage}{.4\textwidth}
\hackOne
\end{minipage}
\vskip1em
It's possible because data representation specifies
\begin{itemize}
\item arity first
\item contents of a list later
\end{itemize}
\end{subfigure}
\end{figure}
\footnote{W.E. Byrd et al. \miniKanren{}, Live and Untagged: Quine Generation via Relational Interpreters. 2012}
\end{frame}

\defverbatim[colored]{\XXX}{
\begin{minted}{ocaml}
(* very much simplified *)
type exp =
  | Quote of exp
  | List of exp list
  | Appl of exp * exp
  | Lam of var * exp * exp
  | ...
\end{minted}
}
\defverbatim[colored]{\BuggyIneq}{
\begin{minted}{ocaml}
(* not quite a solution *)
fresh (v) (q =/= quote v)
\end{minted}
}
\begin{frame}{\OCanren{} Uses Different Representation of Values}
\begin{figure}[ht]
\begin{subfigure}[ht]{.45\textwidth}
\begin{minipage}{.4\textwidth}
\XXX
\end{minipage}
\vskip1em
In \OCanren{} we specify constructor \emph{first} and arity and arguments \emph{later}
\end{subfigure}\hskip2em
\begin{subfigure}[ht]{.49\textwidth}
  \textbf{Question}: how to say that expression \mintinline{ocaml}|q| doesn't fit the first case (is not a quote expression)?
  \begin{center}
  \begin{minipage}{.4\textwidth}
        \BuggyIneq
        \end{minipage}
  \end{center}

        We said: \emph{exists v such that \mintinline{ocaml}{q} is not \mintinline{ocaml}{quote v}}\\

        We wanted to say: \emph{\mintinline{ocaml}{q} is not \mintinline{ocaml}{quote v} for any possible \mintinline{ocaml}{v}.}\\

        In other words: $\forall$ v: \mlinline{q =/= quote v}.
\end{subfigure}
\end{figure}
\footnote{D. Kosarev and D. Boulytchev. Typed Embedding of a Relational  Language in \OCaml{}. 2016}
\end{frame}

\begin{frame}{Isn't this issue too ad hoc?}
\begin{itemize}
\item It may look like too specific for relational interpreters...
\item ... or to \OCanren{} itself
\item But we managed to found an example, that make sense bot for \Scheme{}/\miniKanren{} and \OCaml{}/\OCanren{}
\end{itemize}

\end{frame}

\begin{frame}{Example with Peano Numbers}

What would be solutions for \mintinline{scheme}{q}, that is not equal \mintinline{scheme}{(s (s (s ,v))))} for any possible \mintinline{scheme}{v}?

\begin{itemize}
\item[\faGood] 0 $\Leftrightarrow$ \mintinline{scheme}{z}
\item[\faGood] 1 $\Leftrightarrow$ \mintinline{scheme}{(s z)}
\item[\faGood] 2 $\Leftrightarrow$ \mintinline{scheme}{(s (s z))}
\item[\faBad]  3 $\Leftrightarrow$ \mintinline{scheme}{(s (s (s z)))}
\item[\faBad]  4 $\Leftrightarrow$ \mintinline{scheme}{(s (s (s (s z))))}
\item[\faBad]  5 $\Leftrightarrow$ \mintinline{scheme}{(s (s (s (s (s z)))))}
\item ...
\item All Peano numbers less than three fit, others doesn't
\end{itemize}
\end{frame}

\begin{frame}{Contributions}
\begin{enumerate}
\item Wildcard Logic Variables
\begin{itemize}
\item Are able to express ``Peano number that is \emph{less} than constant N''
\item Previously, we could only do ``Peano number that is  \emph{greater} than constant N''
\end{itemize}
\item An application to \noCanren{} -- more expressivity
\item Work in progress application to pattern-matching synthesis
\end{enumerate}
\end{frame}

\begin{frame}{Implementation Sketch}
We introduce a special \emph{wildcard variables} (denoted by two underscores: \mlinline{__}) and

\begin{itemize}
\item \emph{modify unification}: wildcards unify with everything but don't extend current substitution
\item disequality constraints doesn't change significantly
\end{itemize}
%\begin{figure}[ht]
%\begin{subfigure}[t]{.45\textwidth}
%
%\end{subfigure}\hskip1em
%\begin{subfigure}[t]{.45\textwidth}
\vskip1em
Examples (\Scheme{}-like syntax):
\begin{itemize}
\item  \mlinline{(=/= (1 _.10)  (__ 2))} $\rightsquigarrow$
  \mlinline{(=/= _.10 2)}
\item \mlinline{(=/= _.10 (__  __) )} $\wedge$ \mlinline{(=== _.10 (_.11 _.12))}
$\rightsquigarrow$ fail
\item A fresh variable \mlinline{(=/= _.10  __)}. \\
If a variable has non-empty domain, $\rightsquigarrow$ fail.\\
For empty domain $\rightsquigarrow$ success
\end{itemize}
\end{frame}


\begin{frame}{Related Works}
\begin{enumerate}
\item Eigen variables
\begin{itemize}
\item Universal quantifier inside unification
\item Disequality constraints are not required\footnotemark
\end{itemize}
\item Universal Quantification and Implication\footnotemark
\begin{itemize}
\item Needs more polishing
\end{itemize}
\end{enumerate}
\footnotetext[1]{W. E. Byrd. 2013. Relational Synthesis of Programs.}
\footnotetext[2]{E. Jin, G. Rosenblatt, M. Might, and Zhang L. 2021. Universal Quantification
and Implication in \miniKanren{}.}
%\footnote[frame,3]{Here is a footnote}
\end{frame}

\begin{frame}{An application: \noCanren{} -- \OCaml{} to \OCanren{} translator}
\begin{itemize}
\item [\faBad] \miniKanren{} requires some time to study (as any language/DSL)
\item An idea: synthesize relational code from a subset of general purpose language (for example, \OCaml{})\footnote{P. Lozov, A. Vyatkin, and D. Boulytchev. 2018. Typed Relational Conversion.}
\begin{itemize}
	\item Joint work of P.Lozov and others in our group
\item[\faGood] Type checker for free
\item[\faGood] Convenient \OCaml{}-like syntax  for free (at least it should be)
\item Semantics preserving transformation to \miniKanren{} is proved on paper
\end{itemize}
\item  Restrictions on subset of \OCaml{} (LozovML) are quite strong
\begin{itemize}
\item Some \OCaml{} best practices hurt performance
\item Some language features are not available (pattern matching guards)
\item Overlapping patterns in pattern matching are banished\\
But wildcard variables will help with that \faGood

\end{itemize}
\end{itemize}
\end{frame}

\defverbatim[colored]{\lozovMLexOne}{
\begin{minted}{ocaml}
(* LozovML *)
match x,y with
| T, _ -> 1
| _, _ -> 2
\end{minted}
}
\defverbatim[colored]{\straightforwardCompilation}{
\begin{minted}{ocaml}
let straightforward q rez = (* OCanren syntax *)
  conde
    [ fresh ()
        (rez === !!1)
        (q === pair !!true __)
    ; fresh (l r)
        (rez === !!2)
        (q === pair l r)
    ]
\end{minted}
}
\defverbatim[colored]{\naiveCompilation}{
\begin{minted}{ocaml}
let naive_rel q rez = (* OCanren syntax *)
  conde
    [ fresh (tmp)
        (q === pair !!true tmp)
        (rez === !!1)
    ; fresh (tmp l r)
        (q =/= pair !!true tmp)
        (q === pair l r)
        (rez === !!2)
    ]
\end{minted}
}

\defverbatim[colored]{\betterCompilation}{
\begin{minted}{ocaml}
let better_rel q rez = (* OCanren syntax *)
  conde
    [ fresh ()
        (q === pair !!true __)
        (rez === !!1)
    ; fresh ()
        (q =/= pair !!true __)
        (rez === !!2)
    ]
\end{minted}
}

\begin{frame}{\noCanren{} example
  \only<1>{1}\only<2>{2}\only<3>{3}/3:
  \only<1>{No Constraints At All}
  \only<2>{Default Disequality Constrains}
  \only<3>{Disequality With Wildcard Variables}
  }
\begin{figure}[ht]
\begin{subfigure}[t]{.25\textwidth}
  \begin{minipage}{1\textwidth}
      \vspace{-1em}
  Overlapping patterns are banned, let's see what could go wrong...
  \vspace{1em}
  \lozovMLexOne
  \end{minipage}
\vskip1em
\only<3>{

  An idea: for every branch
  \begin{itemize}
    \item put current pattern as is
    \item previous ones with \mlinline{=/=} and \mlinline{__}
  \end{itemize}
}
\end{subfigure}\hskip3em
\begin{subfigure}[t]{.65\textwidth}
\only<1>{
  \begin{minipage}{.55\textwidth}
  \straightforwardCompilation
  \end{minipage}
  \begin{itemize}
  \item [\faBad] no restrictions between matching branches, can ``return''  both 1 and 2 for \mlinline{fresh (v) (q === pair !!true v)}
  \end{itemize}
}
\only<2>{
  %\vskip{-0.1em}
  \begin{minipage}{.45\textwidth}
  \naiveCompilation
  \end{minipage}
  \begin{itemize}
  \item [\faBad] For \mlinline{fresh (v) (q === pair !!true v)} both 1 and 2, because variable \mlinline{tmp} is existential.

   Restrictions established by default disequality constraints are not powerful enough
  \end{itemize}
}
\only<3>{
  \begin{minipage}{.45\textwidth}
  \betterCompilation
  \end{minipage}
  \begin{itemize}
  \item [\faGood] If \mlinline{q} fits \mlinline{fresh (v) (q === pair !!true v)} the piece of code reaches \mlinline{rez === 1} and doesn't reach second branch (which is expected)
  \end{itemize}
}
\end{subfigure}
\end{figure}
\end{frame}

\begin{frame}{Application to Pattern Matching Synthesis}

\begin{figure}[ht]
\begin{subfigure}[t]{.49\textwidth}
Input language:
\[
 \begin{array}{rcll}
    \mathcal{C} & = & \{ C_1^{k_1}, \dots, C_n^{k_n} \}\\
    \mathcal{V} & = & \mathcal{C}\,\mathcal{V}^*\\
    \mathcal{P} & = & \_ \mid \mathcal{C}\,\mathcal{P}^*
 \end{array}
\]
Declarative semantics  $\trans{}{}{}$:
\[
\setarrow{\xrightarrow}
 \begin{array}{rcl}
    &\trans{\inbr{v;\,p_1,\dots,p_k}}{}{i} &   \\
    &1\leqslant i\leqslant k \\
    & v \in \mathcal{V}  \\
    & p_1,\dots,p_k \in \mathcal{P} &
 \end{array}
\]
\end{subfigure}
\begin{subfigure}[t]{.49\textwidth}
Language of compiled representation (semantics denoted as  $\setsubarrow{_{\mathcal S}}\trans{}{}{}$)
\[
\begin{array}{rcl}
  \mathcal M & =        & \bullet \\
             &    \mid  & \mathcal M\,[\mathbb{N}] \\
  \ir        & =        & \primi{return}\;\mathbb{N} \\
             &    \mid  & \primi{if}\;\mathcal{M}\;\primi{starts with}\;\mathcal{C}\;\primi{then}\; \ir\;\primi{else}\;\ir
\end{array}
\]
Synthesis task:
\begin{center}
$\setarrow{\xrightarrow}
\forall v\in \mathcal V,\; \forall 1\leqslant i\leqslant n: $\\
$\trans{\inbr{v;\,p_1,\dots,p_n}}{}{i}$\\
$\Longleftrightarrow$ \\
$\setsubarrow{_{\mathcal S}}\withenv{v}{\trans{\pi}{}{i}}$ \\
\end{center}

\end{subfigure}
\end{figure}
\end{frame}

\begin{frame}{$\forall$ Quantifier Elimination}
For a concrete pattern matching we know
\begin{itemize}
  \item type of a scrutinee
  \item depth of matching
\end{itemize}
\vskip1em
and we can replace $\forall$ by a finite conjunction of ground examples of scrutinee

\begin{itemize}
  \item [\faGood] Finite conjunction could finish...
  \item [\faBad] Exponential number of examples is really slow
\end{itemize}
\vskip2em
Long-term plan: replace a large finite conjunction by something smaller
\end{frame}

\defverbatim[colored]{\MarangetExample}{
\begin{minted}{ocaml}
match x, y, z with
| _, F, T -> 1
| F, T, _ -> 2
| _, _, F -> 3
| _, _, T -> 4
\end{minted}
}

\defverbatim[colored]{\PartialEnc}{
\begin{minted}{ocaml}
(* Branch 1 in OCanren *)
fresh (tmp1)
  (rez === 1)
  (scru === triple tmp1 F T)

(* Branch 2 in OCanren *)
fresh (tmp1)
  (rez === 1)
  (scru === triple F T tmp1)
  (scru =/= triple __ F T)
(* etc... *)
\end{minted}
}

\begin{frame}[fragile]{An Attempt of Encoding of Pattern Matching Synthesis with Wildcards }
\vspace{-1em}
\begin{figure}[t]
  \begin{subfigure}[ht]{.35\textwidth}
  \begin{minipage}{.1\textwidth}
\MarangetExample
  \end{minipage}
%    \begin{minted}{ocaml}
%match x, y, z with
%| _, F, T -> 1
%| F, T, _ -> 2
%| _, _, F -> 3
%| _, _, T -> 4
%    \end{minted}
  \end{subfigure}
  \begin{subfigure}[t]{.49\textwidth}
  \begin{minipage}{.1\textwidth}
\PartialEnc
  \end{minipage}
%    Branch 1
%    \begin{minted}{ocaml}
%     fresh (tmp1)
%       (rez === 1)
%       (scru === triple tmp1 F T)
%   \end{minted}
%    Branch 2
%    \begin{minted}{ocaml}
%    fresh (tmp1)
%      (rez === 1)
%      (scru === triple F T tmp1)
%      (scru =/= triple __ F T)
%    (* etc... *)
%    \end{minted}
  \end{subfigure}
\end{figure}
\begin{itemize}
%\vskip1em
\item [\faGood] We managed in current branch to ``ban'' previous branches (by adding negative information)
\item [\faBad] Unifications (positive information) have existential holes which allows synthesizer to give undesired answers (in paper we call it ``conservative approximation of scrutinee'' )
\end{itemize}
\end{frame}

\begin{frame}{Results}
\begin{enumerate}
\item[\faCheckGreen] Wildcard Logic Variables
\begin{itemize}
\item Are able to express ``Peano number that is \emph{less} than constant N''
\item Previously, we could only do ``Peano number that is  \emph{greater} than constant N''
\end{itemize}
\item[\faCheckGreen] An application to \noCanren{} -- more expressivity
\item[\faSpinner] Work in progress application to pattern-matching synthesis
\end{enumerate}
\vskip4em
\uncover<2->{
\begin{center}
{\Huge Questions?}
\end{center}
}
\vskip4em
\href{https://github.com/Kakadu/OCanren/tree/wildcards-mk2022}{\faGithubAlt https://github.com/Kakadu/OCanren/tree/wildcards-mk2022}
\end{frame}


\begin{frame}{Technical Remark 1: Motivation for Finite Domain Constraints}
	\[
	\begin{array}{rcl}
		\mathcal M & =        & \bullet \\
		&    \mid  & \mathcal M\,[\mathbb{N}] \\
		\ir        & =        & \primi{return}\;\mathbb{N} \\
		&    \mid  & \primi{if}\;\mathcal{M}\;\primi{starts with}\;\mathcal{C}\;\primi{then}\; \ir\;\primi{else}\;\ir
	\end{array}
	\]
	While evaluating \textbf{if} expression above disequality constraints may give empty domain...\\

	For example we can easily get in the answer \mlinline{_.10 { =/= true; =/= false }}.\\

	We implemented finite domain constraints (based on Z3) to workaround that.
\end{frame}


\defverbatim[colored]{\LowerWildcardUnif}{
\begin{minted}{ocaml}
fresh (x)
  (q === triple x true false)

(* OCanren *)
\end{minted}
}

\begin{frame}{Technical Remark 2: What About Wildcards in Unification?}
	\begin{figure}[ht]
		\begin{subfigure}[ht]{.4\textwidth}
			Our wildcard variables are designed to work combined with disequality constraints
			\vskip2em
			We also supported ``wildcards'' in unification with completely different semantics
		\end{subfigure}
		\hskip2cm
		\begin{subfigure}[ht]{.4\textwidth}
			\begin{minipage}{\textwidth}
				\mlinline{q === triple __ true false}
				\vspace{-0.5em}
				\[
				\Updownarrow
				\]
				\vspace{-0.5em}
				\LowerWildcardUnif
			\end{minipage}

		\end{subfigure}
	\end{figure}
\end{frame}



\defverbatim[colored]{\ExpandWC}{
\begin{minted}{ocaml}
(* OCanren *)
q === cons __ __

(* is translated to *)
call_wc (fun temp1 ->
  call_wc (fun temp2 ->
    (q === cons temp1 temp2)))
\end{minted}
}

\begin{frame}{Technical Remark 3: Typing of wildcards?}
	Occurrences of wildcards may have different type, for example a list: \mlinline{cons __ __}.

	During macro expansion every wildcard is translated to a specific call of \mlinline{call_wc}
	\begin{center}


		\begin{minipage}{\linewidth}
			\ExpandWC
		\end{minipage}
	\end{center}

	But \emph{internally we have a single wildcard} variable.
\end{frame}


\end{document}
