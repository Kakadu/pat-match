open OCanren

let flip f a b = f b a

module W = Typs_rel
open W

let id x = x
let ( >>=? ) x f = match x with None -> None | Some x -> f x
let failwiths fmt = Printf.ksprintf failwith fmt

(* ************************************************************************** *)
(* Natural numbers generated by work (i.e. not from OCanren stdlib) *)
module N = struct
  [%%distrib
  type nonrec 'a t = 'a W.gnat = Z | S of 'a
  [@@deriving gt ~options:{ show; fmt; foldl; gmap; compare }]

  type ground = ground t]

  (* type logic = logic gnat OCanren.logic
     [@@deriving gt ~options:{ fmt; foldl; gmap; compare }] *)

  (* type injected = (ground, logic) OCanren.injected *)

  let z : injected = W.z ()
  let one : injected = W.s z
  let s = W.s

  let show (n : ground) =
    let rec helper acc = function
      | Z -> string_of_int acc
      | S n -> helper (acc + 1) n
    in
    helper 0 n

  let show_logic n =
    let rec helper acc : logic -> string = function
      | Value Z -> string_of_int acc
      | Value (S n) -> helper (acc + 1) n
      | Var _ as n ->
          if acc <= 0 then GT.show OCanren.logic (show_gnat_logic 0) n
          else
            Printf.sprintf "(%d+%s)" acc
              (GT.show OCanren.logic (show_gnat_logic 0) n)
    and show_gnat_logic acc : logic gnat -> string = function
      | Z -> string_of_int acc
      | S n -> helper (acc + 1) n
    in
    helper 0 n

  let ground =
    {
      ground with
      GT.plugins =
        object
          method show = show
          method fmt = ground.GT.plugins#fmt
          method foldl = ground.GT.plugins#foldl
          method compare = ground.GT.plugins#compare
          method gmap = id
        end;
    }

  let logic =
    {
      logic with
      GT.plugins =
        object
          method show = show_logic
          method fmt = logic.GT.plugins#fmt
          method foldl = logic.GT.plugins#foldl
          method compare = logic.GT.plugins#compare
          method gmap = id
        end;
    }

  (* *********** *)

  (* let rec reify env x = W.For_gnat.reify reify env x *)
  (* let rec prjc onvar env xs = W.For_gnat.prjc (prjc onvar) onvar env xs *)

  let inject : ground -> injected =
   fun root ->
    let rec helper = function Z -> z | S p -> s @@ helper p in
    helper root

  let to_ground_exn n =
    let rec helper = function
      | Var _ -> raise Not_found
      | Value Z -> Z
      | Value (S x) -> S (helper x)
    in
    helper n

  let rec to_ground = function
    | Var (_, _) -> None
    | Value Z -> Some Z
    | Value (S x) -> to_ground x >>=? fun x -> Some (S x)

  let of_int n =
    let rec helper acc n = if n = 0 then acc else helper (S acc) (n - 1) in
    if n < 0 then assert false else helper Z n

  let to_int =
    let rec helper acc = function Z -> acc | S x -> helper (acc + 1) x in
    helper 0
end

(* ************************************************************************** *)
module Tag = struct
  type ground = GT.int [@@deriving gt ~options:{ foldl; compare }]
  type logic = GT.int OCanren.logic [@@deriving gt ~options:{ foldl; compare }]
  type injected = GT.int OCanren.ilogic

  let all_tags =
    [
      "zero";
      "succ";
      "true";
      "false";
      "nil";
      "cons";
      "nil2";
      "pair";
      "A";
      "B";
      "C";
      "int";
      "triple";
      "D";
      "Push";
      "Search";
      "Ldi";
      "Pushenv";
      "Popenv";
      "Extend";
      "Apply";
      "Mkclos";
      "Mkclosrec";
      "IOp";
      "Test";
      "Clo";
      "Int";
      "Val";
      "Env";
      "Code";
      "42";
    ]

  let of_int x = x
  let to_int x = x

  let string_of_tag_exn tag =
    let n = to_int tag in
    match List.nth all_tags n with
    | s -> s
    | exception Not_found ->
        failwith (Printf.sprintf "Bad argument %d in tag_of_string_exn" n)

  let inttag_of_string_exn s =
    match Base.List.findi all_tags ~f:(fun _ -> String.equal s) with
    | Some (n, _) -> n
    | None -> failwith (Printf.sprintf "Bad argument %S in tag_of_string_exn" s)

  let tag_of_string_exn s : ground = of_int (inttag_of_string_exn s)
  let of_string_exn = tag_of_string_exn

  exception HasFreeVars

  (*
  let show_logic l =
    let rec helper acc = function
      | Value Z -> acc
      | Value (S next) -> helper (1+acc) next
      | Var _ -> raise HasFreeVars
    in
    try string_of_tag_exn (N.of_int (helper 0 l))
    with HasFreeVars -> GT.show N.logic l
  *)

  let rec is_coercible_to_ground tag =
    match tag with
    | Value Z -> true
    | Var _ -> false
    | Value (S p) -> is_coercible_to_ground p

  let show_logic = GT.show OCanren.logic @@ string_of_tag_exn

  let ground =
    {
      ground with
      GT.plugins =
        object
          method show = string_of_tag_exn
          method fmt f x = Format.fprintf f "@[%s@]" (string_of_tag_exn x)
          method gmap x = x
          method foldl = ground.GT.plugins#foldl
          method compare = ground.GT.plugins#compare
        end;
    }

  let logic =
    {
      logic with
      GT.plugins =
        object
          method show = show_logic
          method fmt f l = Format.fprintf f "@[%s@]" (show_logic l)
          method gmap x = x
          method foldl = logic.GT.plugins#foldl
          method compare = logic.GT.plugins#compare
        end;
    }

  let to_ground_exn = function Value x -> x | Var _ -> failwith "bad argument"
  let reify = OCanren.reify
  let inject = ( !! )
  let prj_exn = OCanren.prj_exn
  let to_ground = function Var _ -> None | Value x -> x
end

(* TODO: put this to stdlib *)
let rec inject_ground_list (xs : 'a OCanren.ilogic Std.List.ground) :
    'a ilogic Std.List.injected =
  (* TODO: tail recursion *)
  let rec helper = function
    | Std.List.Nil -> Std.List.nil ()
    | Std.List.Cons (x, xs) -> Std.List.cons x (helper xs)
  in
  helper xs

let ground_list_length xs = GT.foldl Std.List.ground (fun acc _ -> acc + 1) 0 xs

let ground_list_iteri f xs =
  GT.foldl Std.List.ground
    (fun acc x ->
      f acc x;
      acc + 1)
    0 xs
  |> ignore

let ground_list_foldi f init xs =
  GT.foldl Std.List.ground
    (fun (i, acc) x ->
      let ans = f acc i x in
      (i + 1, ans))
    (0, init) xs
  |> snd

let ground_list_fold2i_exn f init xs ys =
  let open Std.List in
  let rec helper acc n = function
    | Nil, Nil -> acc
    | Cons (x, xs), Cons (y, ys) -> helper (f acc n x y) (n + 1) (xs, ys)
    | _ -> failwith "bad length"
  in
  helper init 0 (xs, ys)

let logic_list_len_lo xs =
  let rec helper acc = function
    | Var (_, _) -> acc
    | Value (Std.List.Cons (_, tl)) -> helper (acc + 1) tl
    | Value Std.List.Nil -> acc
  in
  helper 0 xs

(* module MatchableKind = struct
     type injected = gmatchable_kind OCanren.ilogic

     let pp_logic ppf x =
       GT.fmt logic
         (fun ppf -> function
           | GoodSubTree -> Format.fprintf ppf "good"
           | MissExample -> Format.fprintf ppf "miss"
           | MissTotally -> assert false)
         ppf x

     let good : injected = goodSubTree ()
     let miss_example : injected = missExample ()
     let miss_totally : injected = missTotally ()
     let reify = OCanren.reify
   end *)

module Pattern = struct
  [%%distrib
  type nonrec ('a, 'b) t = ('a, 'b) W.gpattern = WildCard | PConstr of 'a * 'b
  [@@deriving gt ~options:{ fmt; gmap; foldl }]

  type ground = (Tag.ground, ground Std.List.ground) t]

  let constr = W.pConstr
  let wc = W.wildCard

  let rec height = function
    | WildCard -> 0
    | PConstr (_, ps) ->
        GT.foldl Std.List.ground (fun acc x -> max acc (height x)) 0 ps + 1

  let parented flg pp fmt x =
    if flg then Format.fprintf fmt "(%a)" pp x else pp fmt x

  let show : ground -> string =
    let pp ppf =
      GT.transform ground
        (fun fself ->
          object
            method c_WildCard ppf _ = Format.fprintf ppf "_"

            method c_PConstr ppf _ name ps =
              match ps with
              | Std.List.Nil -> Format.fprintf ppf "%a" (GT.fmt Tag.ground) name
              | ps ->
                  Format.fprintf ppf "%a (" (GT.fmt Tag.ground) name;
                  ground_list_iteri
                    (fun n x ->
                      if n > 0 then Format.fprintf ppf ", ";
                      fself ppf x)
                    ps;
                  Format.fprintf ppf ")"
          end)
        ppf
    in
    Format.asprintf "%a" pp

  (*
    let rec helper ~par ppf = function
    | WildCard -> Format.fprintf ppf "_"
    | PConstr (t, Std.List.Nil) ->
        Format.fprintf ppf "%a" (parented par (GT.fmt Tag.ground)) t
    | PConstr (s, ps) ->
        (* TODO: write decent code here  *)
        Format.fprintf ppf "(%s "
(*          (if par then "(" else "")*)
          (GT.show Tag.ground s);
        let (_:int) = GT.foldl Std.List.ground (fun n x ->
            Format.fprintf ppf "%s, %a"
              (if n=0 then "" else ",")
              (helper ~par:false) x;
            (1+n)
          ) 0 ps
        in
        (*Format.fprintf ppf "%a"
          (GT.fmt Std.List.ground (helper ~par:true)) ps;*)
        Format.fprintf ppf ")"
(*          (if par then ")" else "")*)
    in
    Format.asprintf "%a" (helper ~par:false)
*)
  let show_logic : logic -> string =
    let rec helper : (Tag.logic, logic Std.List.logic) t -> string = function
      | WildCard -> "_"
      | PConstr (s, OCanren.Value Std.List.Nil) ->
          let (_ : Tag.logic) = s in
          GT.show Tag.logic s
      | PConstr (s, ps) ->
          Printf.sprintf "(%s %s)" (GT.show Tag.logic s)
            (GT.show Std.List.logic (GT.show OCanren.logic helper) ps)
    in
    GT.show OCanren.logic helper

  let count_constructors : ground -> int =
    GT.transform ground
      (fun fself ->
        object
          method c_PConstr acc _ _ args =
            GT.foldl OCanren.Std.List.ground fself (1 + acc) args

          method c_WildCard acc _ = acc
        end)
      0

  let count_wildcards : ground -> int =
    GT.transform ground
      (fun fself ->
        object
          method c_PConstr acc _ _ args =
            GT.foldl OCanren.Std.List.ground fself acc args

          method c_WildCard acc _ = acc + 1
        end)
      0
end

(* ************************************************************************** *)
module Expr = struct
  [%%distrib
  type nonrec ('a1, 'a0) t = ('a1, 'a0) W.gexpr = EConstr of 'a1 * 'a0
  [@@deriving gt ~options:{ gmap; compare }]

  type ground = (Tag.ground, ground Std.List.ground) t]

  (* type logic = (Tag.logic, logic Std.List.logic) gexpr OCanren.logic *)
  (* type injected = (ground, logic) OCanren.injected *)

  (* let rec prjc onvar : injected -> ground =
     For_gexpr.prjc
       (Tag.prjc (fun _ _ -> assert false))
       (Std.List.prjc prjc (fun _ _ -> assert false))
       (fun _ _ -> assert false)
       onvar *)

  let constr : Tag.injected -> _ -> injected = eConstr
  let leaf t = constr t (OCanren.Std.nil ())
  let econstr s xs = EConstr (Tag.tag_of_string_exn s, Std.List.of_list id xs)
  let eleaf s = econstr s []
  let pair a b = constr !!(Tag.inttag_of_string_exn "pair") Std.(a %< b)
  let true_ = constr !!(Tag.inttag_of_string_exn "true") Std.(nil ())
  let false_ = constr !!(Tag.inttag_of_string_exn "false") Std.(nil ())

  let height : ground -> int =
    let rec helper (EConstr (_, xs)) =
      GT.foldl Std.List.ground (fun acc x -> max acc (helper x)) 0 xs + 1
    in
    helper

  let show : ground -> string =
    let rec helper pars x =
      match x with
      | EConstr (c, Std.List.Nil) when pars ->
          Printf.sprintf "(%s)" (GT.show Tag.ground c)
      | EConstr (c, Std.List.Nil) -> GT.show Tag.ground c
      | EConstr (s, xs) when pars ->
          Printf.sprintf "(%s %s)" (GT.show Tag.ground s)
            (GT.show Std.List.ground (helper false) xs)
      | EConstr (s, xs) ->
          Printf.sprintf "%s %s" (GT.show Tag.ground s)
            (GT.show Std.List.ground (helper false) xs)
    in
    helper false

  let rec show_logic (x : logic) : string =
    let rec helper x =
      match x with
      | EConstr (s, xs) ->
          Printf.sprintf "(%s %s)" (GT.show Tag.logic s)
            (GT.show Std.List.logic show_logic xs)
    in
    GT.show OCanren.logic helper x

  let pp_logic ppf x = Format.fprintf ppf "%s" (show_logic x)

  (* let rec reify env x =
     For_gexpr.reify OCanren.reify (Std.List.reify reify) env x *)

  let inject (e : ground) : injected =
    let rec helper = function
      | EConstr (t, xs) ->
          constr (Tag.inject t)
            (inject_ground_list @@ GT.gmap Std.List.ground helper xs)
    in
    helper e

  let logic =
    {
      GT.gcata = ();
      GT.fix = (fun _ -> assert false);
      GT.plugins =
        object
          method fmt = pp_logic
        end;
    }
end

let pwc = WildCard
let __ = pwc

let pconstr name xs =
  PConstr (Tag.tag_of_string_exn name, Std.List.of_list id xs)

let pleaf s = pconstr s []
let pnil = pleaf "nil"
let pnil2 = pleaf "nil2"
let pzero = pleaf "zero"
let ptrue = pleaf "true"
let pfalse = pleaf "false"
let pcons a b = pconstr "cons" [ a; b ]
let psucc a = pconstr "succ" [ a ]
let psome a = pconstr "some" [ a ]
let ppair a b = pconstr "pair" [ a; b ]
let ptriple a b c = pconstr "triple" [ a; b; c ]

(* ************************************************************************** *)

module Matchable = struct
  [%%distrib
  type nonrec ('a1, 'a0) t = ('a1, 'a0) W.gmatchable =
    | Scru
    | Field of 'a1 * 'a0
  [@@deriving gt ~options:{ foldl; fmt; gmap; compare }]

  type ground = (N.ground, ground) t]

  (* type logic = (N.logic, logic) gmatchable OCanren.logic
     [@@deriving gt ~options:{ foldl; fmt; gmap; compare }]

     type injected = (ground, logic) OCanren.injected *)

  let scru = scru
  let field = field
  let field0 () = field (z ()) @@ scru ()
  let field1 () = field (s (z ())) @@ scru ()
  let field2 () = field (s (s (z ()))) @@ scru ()
  let field00 () = field (z ()) @@ field0 ()
  let field01 () = field (s (z ())) @@ field0 ()
  let field10 () = field (z ()) @@ field1 ()
  let field11 () : injected = field (s (z ())) @@ field1 ()

  let rec show_logic x =
    let rec helper = function
      | Scru -> "S"
      | Field (n, r) -> Printf.sprintf "%s[%s]" (show_logic r) (N.show_logic n)
    in
    GT.show OCanren.logic helper x

  let show x =
    let rec helper = function
      | Scru -> "S"
      | Field (n, r) -> Printf.sprintf "%s[%s]" (helper r) (N.show n)
    in
    helper x

  let ground =
    {
      GT.gcata = gcata_ground;
      GT.fix = ground.GT.fix;
      GT.plugins =
        object
          method fmt f x = Format.fprintf f "@[%s@]" (show x)
          method show = show
          method gmap = ground.GT.plugins#gmap
          method compare = ground.GT.plugins#compare
        end;
    }

  let logic =
    {
      GT.gcata = gcata_logic;
      GT.fix = logic.GT.fix;
      GT.plugins =
        object
          method fmt f x = Format.fprintf f "@[%s@]" (show_logic x)
          method show = show_logic
          method gmap = logic.GT.plugins#gmap
          method compare = logic.GT.plugins#compare
        end;
    }

  (* let rec reify env (x : injected) : logic =
     For_gmatchable.reify N.reify reify env x *)

  let inject : ground -> injected =
   fun root ->
    let rec helper = function
      | Scru -> scru ()
      | Field (n, prev) -> field (N.inject n) (helper prev)
    in
    helper root

  let height_ground m : int =
    GT.transform ground
      (fun fself ->
        object
          inherit [_, _] foldl_ground_t fself
          method m_Scru acc _ = acc + 1
          method m_Field acc _ _ prev = fself (acc + 1) prev
        end)
      0 m

  let to_ground l =
    let rec helper = function
      | Value Scru -> Some Scru
      | Value (Field (n, m)) ->
          N.to_ground n >>=? fun n ->
          helper m >>=? fun m -> Some (Field (n, m))
      | Var (_, _) -> None
    in
    helper l

  let ground_to_list_repr : ground -> N.ground list =
    let rec helper acc = function
      | Scru -> acc
      | Field (n, m) -> helper (n :: acc) m
    in
    helper []

  let low_height_of_logic root =
    let rec helper len = function
      | Value (Field (_, next)) -> helper (len + 1) next
      | Value Scru | Var (_, _) -> len + 1
    in
    let ans = helper 0 root in
    (*      Format.printf "check_scrutinee: length `%s` = %d\n%!" (Matchable.show_logic root) ans;*)
    ans

  module Set = Stdlib.Set.Make (struct
    type t = logic

    let compare = compare
  end)
end

(* ************************************************************************** *)

module IR = struct
  [%%distrib
  type nonrec ('a1, 'self, 'a0) t = ('a1, 'self, 'a0) gir =
    | Fail
    | ITE of 'a1 * 'a0 * 'self * 'self
    | Lit of 'a0
  [@@deriving gt ~options:{ show; fmt; gmap; compare }]

  type ground = (Matchable.ground, ground, GT.int) t]

  type injected = (Matchable.injected, injected, GT.int ilogic) t ilogic

  let (_ : (injected, logic) Reifier.t) = reify
  (* type logic =
       ( Matchable.logic,
         (Tag.logic, logic) Std.Pair.logic Std.List.logic,
         logic,
         GT.int OCanren.logic )
       t
       OCanren.logic
     [@@deriving gt ~options:{ show; fmt; gmap; compare }]

     type injected = (ground, logic) OCanren.injected *)

  let fail = fail
  let ite = iTE
  let int = lit
  let lit = lit
  let eint n = Lit n

  let fmt f (ir : ground) =
    GT.transform ground
      (fun fself ->
        object
          inherit [_] fmt_ground_t fself
          method! c_Fail fmt _ = Format.fprintf fmt "fail"
          method! c_Lit fmt _ n = Format.fprintf fmt "(Int %d)" n

          method! c_ITE fmt _ m tag th el =
            Format.fprintf fmt "@[(@[if %a = %a then %a else %a @]"
              (GT.fmt Matchable.ground) m (GT.fmt Tag.ground) tag fself th fself
              el;

            Format.fprintf fmt ")@]"
        end)
      f ir

  let show e =
    let (_ : string) = Format.flush_str_formatter () in
    Format.pp_set_margin Format.str_formatter 10000;
    Format.pp_set_max_indent Format.str_formatter
      (Format.pp_get_margin Format.std_formatter () - 1);
    Format.fprintf Format.str_formatter "%a" fmt e;
    Format.flush_str_formatter ()

  let show_ocl f = GT.show OCanren.logic f
  (* let show_ocl_small f = function
     | Value x -> f x
     | Var (n,_) -> Printf.sprintf "_.%d" n*)

  let show_ocl_small = show_ocl (* PRINTING HACK *)

  let rec fmt_logic fmt (e : logic) =
    let fmt_ocl f fmt x = GT.fmt OCanren.logic f fmt x in
    let rec helper fmt = function
      | Fail -> Format.fprintf fmt "fail"
      | Lit ln ->
          Format.fprintf fmt "(Int %a) "
            (GT.fmt OCanren.logic (GT.fmt GT.int))
            ln
      | ITE (m, tag, th, el) ->
          Format.fprintf fmt "(if %a = %a then %a else %a)"
            (GT.fmt Matchable.logic) m (GT.fmt Tag.logic) tag (fmt_ocl helper)
            th (fmt_ocl helper) el
    in

    fmt_ocl helper fmt e

  let show_logic e =
    let (_ : string) = Format.flush_str_formatter () in
    Format.pp_set_margin Format.str_formatter 10000;
    Format.pp_set_max_indent Format.str_formatter
      (Format.pp_get_margin Format.std_formatter () - 1);
    Format.fprintf Format.str_formatter "%a" fmt_logic e;
    Format.flush_str_formatter ()

  let ground =
    {
      GT.gcata = gcata_ground;
      GT.fix = ground.GT.fix;
      GT.plugins =
        object
          method fmt = fmt
          method show = show
          method gmap = ground.GT.plugins#gmap
        end;
    }

  let logic =
    {
      GT.gcata = gcata_logic;
      GT.fix = logic.GT.fix;
      GT.plugins =
        object
          method fmt = fmt_logic
          method show = show_logic
          method gmap = logic.GT.plugins#gmap
          method show_ast = logic.GT.plugins#show
          method compare = logic.GT.plugins#compare
        end;
    }

  let inject : ground -> injected =
    let rec helper = function
      | Lit n -> int !!n
      | Fail -> fail ()
      | ITE (m, tag, th, el) ->
          ite (Matchable.inject m) (Tag.inject tag) (helper th) (helper el)
    in
    helper

  let count_ifs_ground root =
    GT.transform ground
      (fun fself ->
        object
          method c_Fail acc _ = acc
          method c_Lit acc _ _ = acc
          method c_ITE acc _ _ _ th el = acc + fself 0 th + fself 0 el
        end)
      0 root

  let count_ifs_low : logic -> int =
   fun root ->
    let rec helper : logic -> int = function
      | Var (_, _) -> 0
      | Value (Lit _) | Value Fail -> 0
      | Value (ITE (_, _, th, el)) -> 1 + helper th + helper el
    in

    helper root

  let compare_logic a b = GT.compare logic a b
end

(* let%expect_test _ =
   let open Mytester in
   run_r
     (IR.reify : (IR.injected, IR.logic) Reifier.t)
     (fun ~span:_ s -> [%show: IR.logic] () s)
     1 q qh
     ("", fun (q : IR.injected) -> q === IR.fail ()) *)

module Clauses = struct
  type pre_ground = (Pattern.ground * IR.ground) list
  type ground = (Pattern.ground * IR.ground) Std.List.ground
  type logic = (Pattern.logic, IR.logic) Std.Pair.logic Std.List.logic

  type injected =
    (Pattern.injected, IR.injected) Std.Pair.injected Std.List.injected

  let prj_exn = Std.Pair.prj_exn Pattern.prj_exn IR.prj_exn

  let inject : pre_ground -> injected =
   fun ps ->
    let rec one : Pattern.ground -> _ = function
      | WildCard -> Pattern.wc ()
      | PConstr (name, ps) ->
          Pattern.constr (Tag.inject name)
          @@ inject_ground_list
          @@ GT.gmap Std.List.ground one ps
    in
    Std.List.list
    @@ List.map (fun (p, rhs) -> Std.Pair.pair (one p) (IR.inject rhs)) ps

  let pretty_print ch clauses =
    Format.fprintf ch "@[match ... with@]@.";
    clauses
    |> List.iter (fun (p, ir) ->
           Format.fprintf ch "@[| %s@ ->@ %s@]@." (Pattern.show p) (IR.show ir))
end

module TagSet = Set.Make (struct
  type t = Tag.ground

  let compare = Caml.compare
end)

module Typ_info = struct
  [%%distrib
  type nonrec 'a t = 'a W.gtyp_info = T of 'a
  [@@deriving gt ~options:{ show; fmt; gmap }]

  type ground =
    (Tag.ground, ground Std.List.ground) Std.Pair.ground Std.List.ground t]

  let t eta = W.t eta
  let t_item name xs = Std.Pair.pair name xs

  let rec inject (e : ground) : injected =
    let rec helper : _ -> _ = function
      | s, xs ->
          t_item (Tag.inject s)
            (inject_ground_list @@ GT.gmap Std.List.ground inject xs)
    in
    match e with
    | T xs -> t (inject_ground_list @@ GT.gmap Std.List.ground helper xs)

  let mkt xs : ground = T (Std.List.of_list id xs)

  let get_names (T xs) =
    GT.foldl Std.List.ground
      (fun acc (t, _) -> TagSet.add t acc)
      TagSet.empty xs

  let assoc (T xs) key =
    GT.foldl Std.List.ground
      (fun acc (x, v) ->
        match acc with
        | Some _ as ans -> ans
        | None -> if x = key then Some v else None)
      None xs

  let assoc_exn typs key =
    match assoc typs key with
    | None ->
        failwith
          (Printf.sprintf "Typs.assoc_exn: key '%s' not found in '%s'"
             (GT.show Tag.ground key) (GT.show ground typs))
    | Some x -> x

  type pre_typ = (string * pre_typ list) list t

  let rec construct (root : pre_typ) : ground =
    match root with
    | T xs ->
        mkt
        @@ List.map
             (fun (p, xs) ->
               (Tag.tag_of_string_exn p, Std.List.of_list construct xs))
             xs
end

(* module Triple = struct
     type ('a, 'b, 'c) ground = 'a * 'b * 'c [@@deriving gt ~options:{ fmt; gmap }]

     module F = Fmap3 (struct
       type ('a, 'b, 'c) t = ('a, 'b, 'c) ground

       let fmap eta = GT.gmap ground eta
     end)

     type nonrec ('a, 'b, 'c) logic = ('a, 'b, 'c) ground OCanren.logic

     let reify fa fb fc = F.reify fa fb fc
     let prjc = F.prjc
     let make x y z = inj @@ F.distrib (x, y, z)
   end *)

module CNames = struct
  type ground = Tag.ground Std.List.ground
  type logic = Tag.logic Std.List.logic
  type injected = Tag.injected Std.List.injected
end

module Cases = struct
  type ground = (Tag.ground, IR.ground) Std.Pair.ground Std.List.ground
  type logic = (Tag.logic, IR.logic) Std.Pair.logic Std.List.logic

  type injected =
    (Tag.injected, IR.injected) Std.Pair.injected Std.List.injected
end

module EvalMRez = struct
  type ground = (Expr.ground, CNames.ground) Std.Pair.ground

  (*      [@@deriving gt ~options: { show; fmt }]*)
  type logic = (Expr.logic, CNames.logic) Std.Pair.logic

  (*      [@@deriving gt ~options: { show; fmt }]*)
  type injected = (Expr.injected, CNames.injected) Std.Pair.injected

  let show x =
    GT.(
      show Std.Pair.ground Expr.show (show Std.List.ground @@ show Tag.ground))
      x

  let show_logic x =
    GT.(
      show Std.Pair.logic Expr.show_logic (show Std.List.logic @@ show Tag.logic))
      x

  let reifier env x =
    Std.Pair.reify Expr.reify (Std.List.reify OCanren.reify) env x
end
